/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IStakingDataProvider {
  export type StakeInfoStruct = {
    user: PromiseOrValue<string>;
    targetId: PromiseOrValue<BytesLike>;
    stakeBalance: PromiseOrValue<BigNumberish>;
    rewardBalance: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
    updatedAt: PromiseOrValue<BigNumberish>;
  };

  export type StakeInfoStructOutput = [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    user: string;
    targetId: string;
    stakeBalance: BigNumber;
    rewardBalance: BigNumber;
    createdAt: BigNumber;
    updatedAt: BigNumber;
  };

  export type TargetStruct = {
    targetType: PromiseOrValue<BigNumberish>;
    instanceId: PromiseOrValue<BytesLike>;
    componentId: PromiseOrValue<BigNumberish>;
    bundleId: PromiseOrValue<BigNumberish>;
    data: PromiseOrValue<BytesLike>;
    token: PromiseOrValue<string>;
    chainId: PromiseOrValue<BigNumberish>;
  };

  export type TargetStructOutput = [
    number,
    string,
    BigNumber,
    BigNumber,
    string,
    string,
    BigNumber
  ] & {
    targetType: number;
    instanceId: string;
    componentId: BigNumber;
    bundleId: BigNumber;
    data: string;
    token: string;
    chainId: BigNumber;
  };
}

export interface IStakingInterface extends utils.Interface {
  functions: {
    "calculateCapitalSupport(address,uint256,uint256)": FunctionFragment;
    "calculateRequiredStaking(address,uint256,uint256)": FunctionFragment;
    "calculateRewards(uint256,uint256)": FunctionFragment;
    "calculateRewardsIncrement((address,bytes32,uint256,uint256,uint256,uint256))": FunctionFragment;
    "capitalSupport(bytes32)": FunctionFragment;
    "claimRewards(bytes32)": FunctionFragment;
    "fromRate(uint256)": FunctionFragment;
    "getBundleRegistry()": FunctionFragment;
    "getInfo(bytes32,address)": FunctionFragment;
    "getReserveBalance()": FunctionFragment;
    "getRewardBalance()": FunctionFragment;
    "getRewardRate()": FunctionFragment;
    "getRewardReserves()": FunctionFragment;
    "getStakeBalance()": FunctionFragment;
    "getStakingRate(address,uint256)": FunctionFragment;
    "getStakingWallet()": FunctionFragment;
    "getTarget(bytes32)": FunctionFragment;
    "getTargetId(uint256)": FunctionFragment;
    "hasDefinedStakingRate(address,uint256)": FunctionFragment;
    "hasInfo(bytes32,address)": FunctionFragment;
    "increaseRewardReserves(uint256)": FunctionFragment;
    "isStakingSupported(bytes32)": FunctionFragment;
    "isTarget(bytes32)": FunctionFragment;
    "isTargetRegistered((uint8,bytes32,uint256,uint256,bytes,address,uint256))": FunctionFragment;
    "isUnstakingSupported(bytes32)": FunctionFragment;
    "oneYear()": FunctionFragment;
    "register(bytes32,(uint8,bytes32,uint256,uint256,bytes,address,uint256))": FunctionFragment;
    "setRewardRate(uint256)": FunctionFragment;
    "setStakingRate(address,uint256,uint256)": FunctionFragment;
    "stake(bytes32,uint256)": FunctionFragment;
    "stakes(bytes32)": FunctionFragment;
    "stakes(bytes32,address)": FunctionFragment;
    "targets()": FunctionFragment;
    "toBundleTargetId(bytes32,uint256,uint256)": FunctionFragment;
    "toComponentTargetId(bytes32,uint256)": FunctionFragment;
    "toInstanceTargetId(bytes32)": FunctionFragment;
    "toRate(uint256,int8)": FunctionFragment;
    "toTarget(uint8,bytes32,uint256,uint256,bytes)": FunctionFragment;
    "unstake(bytes32,uint256)": FunctionFragment;
    "unstakeAndClaimRewards(bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "calculateCapitalSupport"
      | "calculateRequiredStaking"
      | "calculateRewards"
      | "calculateRewardsIncrement"
      | "capitalSupport"
      | "claimRewards"
      | "fromRate"
      | "getBundleRegistry"
      | "getInfo"
      | "getReserveBalance"
      | "getRewardBalance"
      | "getRewardRate"
      | "getRewardReserves"
      | "getStakeBalance"
      | "getStakingRate"
      | "getStakingWallet"
      | "getTarget"
      | "getTargetId"
      | "hasDefinedStakingRate"
      | "hasInfo"
      | "increaseRewardReserves"
      | "isStakingSupported"
      | "isTarget"
      | "isTargetRegistered"
      | "isUnstakingSupported"
      | "oneYear"
      | "register"
      | "setRewardRate"
      | "setStakingRate"
      | "stake"
      | "stakes(bytes32)"
      | "stakes(bytes32,address)"
      | "targets"
      | "toBundleTargetId"
      | "toComponentTargetId"
      | "toInstanceTargetId"
      | "toRate"
      | "toTarget"
      | "unstake"
      | "unstakeAndClaimRewards"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "calculateCapitalSupport",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRequiredStaking",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewards",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewardsIncrement",
    values: [IStakingDataProvider.StakeInfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "capitalSupport",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRewards",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "fromRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBundleRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInfo",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakeBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingRate",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTarget",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTargetId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasDefinedStakingRate",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasInfo",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseRewardReserves",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakingSupported",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isTarget",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isTargetRegistered",
    values: [IStakingDataProvider.TargetStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "isUnstakingSupported",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "oneYear", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "register",
    values: [PromiseOrValue<BytesLike>, IStakingDataProvider.TargetStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setRewardRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingRate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakes(bytes32)",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakes(bytes32,address)",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "targets", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "toBundleTargetId",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "toComponentTargetId",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toInstanceTargetId",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "toRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toTarget",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstakeAndClaimRewards",
    values: [PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(
    functionFragment: "calculateCapitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRequiredStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewardsIncrement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "capitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fromRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBundleRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getReserveBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakeBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getTarget", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTargetId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasDefinedStakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseRewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakingSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isTarget", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isTargetRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUnstakingSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "oneYear", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "register", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setRewardRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakes(bytes32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakes(bytes32,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "targets", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "toBundleTargetId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toComponentTargetId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toInstanceTargetId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "toRate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "toTarget", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unstakeAndClaimRewards",
    data: BytesLike
  ): Result;

  events: {
    "LogStakingDipBalanceChanged(uint256,uint256,uint256,int256)": EventFragment;
    "LogStakingRewardRateSet(uint256,uint256)": EventFragment;
    "LogStakingRewardReservesIncreased(address,uint256,uint256)": EventFragment;
    "LogStakingRewardsClaimed(address,bytes32,bytes32,uint256,uint256,uint256,uint256)": EventFragment;
    "LogStakingRewardsUpdated(address,bytes32,bytes32,uint256,uint256,uint256,uint256)": EventFragment;
    "LogStakingStaked(address,bytes32,bytes32,uint256,uint256,uint256,uint256)": EventFragment;
    "LogStakingStakingRateSet(address,uint256,uint256,uint256)": EventFragment;
    "LogStakingTargetRegistered(bytes32,uint8,bytes32,uint256,uint256)": EventFragment;
    "LogStakingUnstaked(address,bytes32,bytes32,uint256,uint256,uint256,uint256)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "LogStakingDipBalanceChanged"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardRateSet"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogStakingRewardReservesIncreased"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardsClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingStaked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingStakingRateSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingTargetRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingUnstaked"): EventFragment;
}

export interface LogStakingDipBalanceChangedEventObject {
  stakeBalance: BigNumber;
  rewardBalance: BigNumber;
  actualBalance: BigNumber;
  reserves: BigNumber;
}
export type LogStakingDipBalanceChangedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber],
  LogStakingDipBalanceChangedEventObject
>;

export type LogStakingDipBalanceChangedEventFilter =
  TypedEventFilter<LogStakingDipBalanceChangedEvent>;

export interface LogStakingRewardRateSetEventObject {
  oldRewardRate: BigNumber;
  newRewardRate: BigNumber;
}
export type LogStakingRewardRateSetEvent = TypedEvent<
  [BigNumber, BigNumber],
  LogStakingRewardRateSetEventObject
>;

export type LogStakingRewardRateSetEventFilter =
  TypedEventFilter<LogStakingRewardRateSetEvent>;

export interface LogStakingRewardReservesIncreasedEventObject {
  user: string;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardReservesIncreasedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardReservesIncreasedEventObject
>;

export type LogStakingRewardReservesIncreasedEventFilter =
  TypedEventFilter<LogStakingRewardReservesIncreasedEvent>;

export interface LogStakingRewardsClaimedEventObject {
  user: string;
  targetId: string;
  instanceId: string;
  componentId: BigNumber;
  bundleId: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardsClaimedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  LogStakingRewardsClaimedEventObject
>;

export type LogStakingRewardsClaimedEventFilter =
  TypedEventFilter<LogStakingRewardsClaimedEvent>;

export interface LogStakingRewardsUpdatedEventObject {
  user: string;
  targetId: string;
  instanceId: string;
  componentId: BigNumber;
  bundleId: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardsUpdatedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  LogStakingRewardsUpdatedEventObject
>;

export type LogStakingRewardsUpdatedEventFilter =
  TypedEventFilter<LogStakingRewardsUpdatedEvent>;

export interface LogStakingStakedEventObject {
  user: string;
  targetId: string;
  instanceId: string;
  componentId: BigNumber;
  bundleId: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingStakedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  LogStakingStakedEventObject
>;

export type LogStakingStakedEventFilter =
  TypedEventFilter<LogStakingStakedEvent>;

export interface LogStakingStakingRateSetEventObject {
  token: string;
  chainId: BigNumber;
  oldStakingRate: BigNumber;
  newStakingRate: BigNumber;
}
export type LogStakingStakingRateSetEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  LogStakingStakingRateSetEventObject
>;

export type LogStakingStakingRateSetEventFilter =
  TypedEventFilter<LogStakingStakingRateSetEvent>;

export interface LogStakingTargetRegisteredEventObject {
  targetId: string;
  targetType: number;
  instanceId: string;
  componentId: BigNumber;
  bundleId: BigNumber;
}
export type LogStakingTargetRegisteredEvent = TypedEvent<
  [string, number, string, BigNumber, BigNumber],
  LogStakingTargetRegisteredEventObject
>;

export type LogStakingTargetRegisteredEventFilter =
  TypedEventFilter<LogStakingTargetRegisteredEvent>;

export interface LogStakingUnstakedEventObject {
  user: string;
  targetId: string;
  instanceId: string;
  componentId: BigNumber;
  bundleId: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingUnstakedEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  LogStakingUnstakedEventObject
>;

export type LogStakingUnstakedEventFilter =
  TypedEventFilter<LogStakingUnstakedEvent>;

export interface IStaking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IStakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    calculateCapitalSupport(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { tokenAmount: BigNumber }>;

    calculateRequiredStaking(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardAmount: BigNumber }>;

    calculateRewardsIncrement(
      info: IStakingDataProvider.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { incrementAmount: BigNumber }>;

    capitalSupport(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { capitalAmount: BigNumber }>;

    claimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fromRate(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; divisor: BigNumber }
    >;

    getBundleRegistry(
      overrides?: CallOverrides
    ): Promise<[string] & { bundleRegistry: string }>;

    getInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [IStakingDataProvider.StakeInfoStructOutput] & {
        info: IStakingDataProvider.StakeInfoStructOutput;
      }
    >;

    getReserveBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { reserves: BigNumber }>;

    getRewardBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardReserves: BigNumber }>;

    getRewardRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    getRewardReserves(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardReserves: BigNumber }>;

    getStakeBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { stakeBalance: BigNumber }>;

    getStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    getStakingWallet(
      overrides?: CallOverrides
    ): Promise<[string] & { stakingWallet: string }>;

    getTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [IStakingDataProvider.TargetStructOutput] & {
        target: IStakingDataProvider.TargetStructOutput;
      }
    >;

    getTargetId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { targetId: string }>;

    hasDefinedStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { hasRate: boolean }>;

    hasInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { hasInfos: boolean }>;

    increaseRewardReserves(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isStakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    isTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isATarget: boolean }>;

    isTargetRegistered(
      target: IStakingDataProvider.TargetStruct,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isRegistered: boolean }>;

    isUnstakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    oneYear(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { yearInSeconds: BigNumber }>;

    register(
      targetId: PromiseOrValue<BytesLike>,
      target: IStakingDataProvider.TargetStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "stakes(bytes32)"(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    "stakes(bytes32,address)"(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    targets(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { numberOfTargets: BigNumber }>;

    toBundleTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { targetId: string }>;

    toComponentTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { targetId: string }>;

    toInstanceTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string] & { targetId: string }>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    toTarget(
      targetType: PromiseOrValue<BigNumberish>,
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [string, IStakingDataProvider.TargetStructOutput] & {
        targetId: string;
        target: IStakingDataProvider.TargetStructOutput;
      }
    >;

    unstake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unstakeAndClaimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  calculateCapitalSupport(
    token: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRequiredStaking(
    token: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    tokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRewards(
    amount: PromiseOrValue<BigNumberish>,
    duration: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRewardsIncrement(
    info: IStakingDataProvider.StakeInfoStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  capitalSupport(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimRewards(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fromRate(
    rate: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { value: BigNumber; divisor: BigNumber }>;

  getBundleRegistry(overrides?: CallOverrides): Promise<string>;

  getInfo(
    targetId: PromiseOrValue<BytesLike>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IStakingDataProvider.StakeInfoStructOutput>;

  getReserveBalance(overrides?: CallOverrides): Promise<BigNumber>;

  getRewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

  getRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

  getRewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

  getStakeBalance(overrides?: CallOverrides): Promise<BigNumber>;

  getStakingRate(
    token: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getStakingWallet(overrides?: CallOverrides): Promise<string>;

  getTarget(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<IStakingDataProvider.TargetStructOutput>;

  getTargetId(
    idx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  hasDefinedStakingRate(
    token: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  hasInfo(
    targetId: PromiseOrValue<BytesLike>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  increaseRewardReserves(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isStakingSupported(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTarget(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isTargetRegistered(
    target: IStakingDataProvider.TargetStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isUnstakingSupported(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  oneYear(overrides?: CallOverrides): Promise<BigNumber>;

  register(
    targetId: PromiseOrValue<BytesLike>,
    target: IStakingDataProvider.TargetStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRewardRate(
    rewardRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingRate(
    token: PromiseOrValue<string>,
    chainId: PromiseOrValue<BigNumberish>,
    stakingRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stake(
    targetId: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "stakes(bytes32)"(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "stakes(bytes32,address)"(
    targetId: PromiseOrValue<BytesLike>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  targets(overrides?: CallOverrides): Promise<BigNumber>;

  toBundleTargetId(
    instanceId: PromiseOrValue<BytesLike>,
    componentId: PromiseOrValue<BigNumberish>,
    bundleId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  toComponentTargetId(
    instanceId: PromiseOrValue<BytesLike>,
    componentId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  toInstanceTargetId(
    instanceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  toRate(
    value: PromiseOrValue<BigNumberish>,
    exp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  toTarget(
    targetType: PromiseOrValue<BigNumberish>,
    instanceId: PromiseOrValue<BytesLike>,
    componentId: PromiseOrValue<BigNumberish>,
    bundleId: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<
    [string, IStakingDataProvider.TargetStructOutput] & {
      targetId: string;
      target: IStakingDataProvider.TargetStructOutput;
    }
  >;

  unstake(
    targetId: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unstakeAndClaimRewards(
    targetId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    calculateCapitalSupport(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRequiredStaking(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewardsIncrement(
      info: IStakingDataProvider.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    capitalSupport(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    fromRate(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { value: BigNumber; divisor: BigNumber }
    >;

    getBundleRegistry(overrides?: CallOverrides): Promise<string>;

    getInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IStakingDataProvider.StakeInfoStructOutput>;

    getReserveBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getStakeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStakingWallet(overrides?: CallOverrides): Promise<string>;

    getTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<IStakingDataProvider.TargetStructOutput>;

    getTargetId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    hasDefinedStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    hasInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    increaseRewardReserves(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isStakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isTargetRegistered(
      target: IStakingDataProvider.TargetStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isUnstakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    oneYear(overrides?: CallOverrides): Promise<BigNumber>;

    register(
      targetId: PromiseOrValue<BytesLike>,
      target: IStakingDataProvider.TargetStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "stakes(bytes32)"(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "stakes(bytes32,address)"(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    targets(overrides?: CallOverrides): Promise<BigNumber>;

    toBundleTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    toComponentTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    toInstanceTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toTarget(
      targetType: PromiseOrValue<BigNumberish>,
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [string, IStakingDataProvider.TargetStructOutput] & {
        targetId: string;
        target: IStakingDataProvider.TargetStructOutput;
      }
    >;

    unstake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    unstakeAndClaimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "LogStakingDipBalanceChanged(uint256,uint256,uint256,int256)"(
      stakeBalance?: null,
      rewardBalance?: null,
      actualBalance?: null,
      reserves?: null
    ): LogStakingDipBalanceChangedEventFilter;
    LogStakingDipBalanceChanged(
      stakeBalance?: null,
      rewardBalance?: null,
      actualBalance?: null,
      reserves?: null
    ): LogStakingDipBalanceChangedEventFilter;

    "LogStakingRewardRateSet(uint256,uint256)"(
      oldRewardRate?: null,
      newRewardRate?: null
    ): LogStakingRewardRateSetEventFilter;
    LogStakingRewardRateSet(
      oldRewardRate?: null,
      newRewardRate?: null
    ): LogStakingRewardRateSetEventFilter;

    "LogStakingRewardReservesIncreased(address,uint256,uint256)"(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesIncreasedEventFilter;
    LogStakingRewardReservesIncreased(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesIncreasedEventFilter;

    "LogStakingRewardsClaimed(address,bytes32,bytes32,uint256,uint256,uint256,uint256)"(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsClaimedEventFilter;
    LogStakingRewardsClaimed(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsClaimedEventFilter;

    "LogStakingRewardsUpdated(address,bytes32,bytes32,uint256,uint256,uint256,uint256)"(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsUpdatedEventFilter;
    LogStakingRewardsUpdated(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsUpdatedEventFilter;

    "LogStakingStaked(address,bytes32,bytes32,uint256,uint256,uint256,uint256)"(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingStakedEventFilter;
    LogStakingStaked(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingStakedEventFilter;

    "LogStakingStakingRateSet(address,uint256,uint256,uint256)"(
      token?: null,
      chainId?: null,
      oldStakingRate?: null,
      newStakingRate?: null
    ): LogStakingStakingRateSetEventFilter;
    LogStakingStakingRateSet(
      token?: null,
      chainId?: null,
      oldStakingRate?: null,
      newStakingRate?: null
    ): LogStakingStakingRateSetEventFilter;

    "LogStakingTargetRegistered(bytes32,uint8,bytes32,uint256,uint256)"(
      targetId?: null,
      targetType?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null
    ): LogStakingTargetRegisteredEventFilter;
    LogStakingTargetRegistered(
      targetId?: null,
      targetType?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null
    ): LogStakingTargetRegisteredEventFilter;

    "LogStakingUnstaked(address,bytes32,bytes32,uint256,uint256,uint256,uint256)"(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingUnstakedEventFilter;
    LogStakingUnstaked(
      user?: null,
      targetId?: null,
      instanceId?: null,
      componentId?: null,
      bundleId?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingUnstakedEventFilter;
  };

  estimateGas: {
    calculateCapitalSupport(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRequiredStaking(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewardsIncrement(
      info: IStakingDataProvider.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    capitalSupport(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fromRate(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBundleRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    getInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    getRewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getStakeBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStakingWallet(overrides?: CallOverrides): Promise<BigNumber>;

    getTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTargetId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasDefinedStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    increaseRewardReserves(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isStakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isTargetRegistered(
      target: IStakingDataProvider.TargetStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isUnstakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oneYear(overrides?: CallOverrides): Promise<BigNumber>;

    register(
      targetId: PromiseOrValue<BytesLike>,
      target: IStakingDataProvider.TargetStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "stakes(bytes32)"(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "stakes(bytes32,address)"(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    targets(overrides?: CallOverrides): Promise<BigNumber>;

    toBundleTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toComponentTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toInstanceTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toTarget(
      targetType: PromiseOrValue<BigNumberish>,
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unstakeAndClaimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    calculateCapitalSupport(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRequiredStaking(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRewardsIncrement(
      info: IStakingDataProvider.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    capitalSupport(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fromRate(
      rate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBundleRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReserveBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRewardBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRewardReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakeBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStakingWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTargetId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasDefinedStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasInfo(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    increaseRewardReserves(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isStakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTarget(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isTargetRegistered(
      target: IStakingDataProvider.TargetStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isUnstakingSupported(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oneYear(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    register(
      targetId: PromiseOrValue<BytesLike>,
      target: IStakingDataProvider.TargetStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingRate(
      token: PromiseOrValue<string>,
      chainId: PromiseOrValue<BigNumberish>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "stakes(bytes32)"(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "stakes(bytes32,address)"(
      targetId: PromiseOrValue<BytesLike>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    targets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    toBundleTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toComponentTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toInstanceTargetId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toTarget(
      targetType: PromiseOrValue<BigNumberish>,
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unstake(
      targetId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unstakeAndClaimRewards(
      targetId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
