/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface MockRegistryStakingInterface extends utils.Interface {
  functions: {
    "BUNDLE()": FunctionFragment;
    "CHAIN()": FunctionFragment;
    "EXP()": FunctionFragment;
    "INSTANCE()": FunctionFragment;
    "MULTIPLIER()": FunctionFragment;
    "NAME()": FunctionFragment;
    "ORACLE()": FunctionFragment;
    "POLICY()": FunctionFragment;
    "PRODUCT()": FunctionFragment;
    "REGISTRY()": FunctionFragment;
    "RISKPOOL()": FunctionFragment;
    "STAKE()": FunctionFragment;
    "SYMBOL()": FunctionFragment;
    "TOKEN()": FunctionFragment;
    "UNDEFINED()": FunctionFragment;
    "capitalSupport(uint96)": FunctionFragment;
    "exists(uint256)": FunctionFragment;
    "exists(uint96)": FunctionFragment;
    "getBundleNftId(bytes32,uint256)": FunctionFragment;
    "getComponentNftId(bytes32,uint256)": FunctionFragment;
    "getDip()": FunctionFragment;
    "getInstanceNftId(bytes32)": FunctionFragment;
    "getNft()": FunctionFragment;
    "getRegistry()": FunctionFragment;
    "getStakingWallet()": FunctionFragment;
    "implementsIStaking()": FunctionFragment;
    "maxRewardRate()": FunctionFragment;
    "mint(address,string)": FunctionFragment;
    "mockRegisterRiskpool(bytes32,uint256)": FunctionFragment;
    "name()": FunctionFragment;
    "objects(bytes5,uint8)": FunctionFragment;
    "owner()": FunctionFragment;
    "rateDecimals()": FunctionFragment;
    "registerBundle(bytes32,uint256,uint256,string,uint256)": FunctionFragment;
    "rewardBalance()": FunctionFragment;
    "rewardRate()": FunctionFragment;
    "rewardReserves()": FunctionFragment;
    "setStakedDip(uint96,uint256)": FunctionFragment;
    "setStakingRate(bytes5,address,uint256)": FunctionFragment;
    "stakingRate(bytes5,address)": FunctionFragment;
    "symbol()": FunctionFragment;
    "toChain(uint256)": FunctionFragment;
    "toRate(uint256,int8)": FunctionFragment;
    "totalMinted()": FunctionFragment;
    "version()": FunctionFragment;
    "versionParts()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BUNDLE"
      | "CHAIN"
      | "EXP"
      | "INSTANCE"
      | "MULTIPLIER"
      | "NAME"
      | "ORACLE"
      | "POLICY"
      | "PRODUCT"
      | "REGISTRY"
      | "RISKPOOL"
      | "STAKE"
      | "SYMBOL"
      | "TOKEN"
      | "UNDEFINED"
      | "capitalSupport"
      | "exists(uint256)"
      | "exists(uint96)"
      | "getBundleNftId"
      | "getComponentNftId"
      | "getDip"
      | "getInstanceNftId"
      | "getNft"
      | "getRegistry"
      | "getStakingWallet"
      | "implementsIStaking"
      | "maxRewardRate"
      | "mint"
      | "mockRegisterRiskpool"
      | "name"
      | "objects"
      | "owner"
      | "rateDecimals"
      | "registerBundle"
      | "rewardBalance"
      | "rewardRate"
      | "rewardReserves"
      | "setStakedDip"
      | "setStakingRate"
      | "stakingRate"
      | "symbol"
      | "toChain"
      | "toRate"
      | "totalMinted"
      | "version"
      | "versionParts"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "BUNDLE", values?: undefined): string;
  encodeFunctionData(functionFragment: "CHAIN", values?: undefined): string;
  encodeFunctionData(functionFragment: "EXP", values?: undefined): string;
  encodeFunctionData(functionFragment: "INSTANCE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MULTIPLIER",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(functionFragment: "ORACLE", values?: undefined): string;
  encodeFunctionData(functionFragment: "POLICY", values?: undefined): string;
  encodeFunctionData(functionFragment: "PRODUCT", values?: undefined): string;
  encodeFunctionData(functionFragment: "REGISTRY", values?: undefined): string;
  encodeFunctionData(functionFragment: "RISKPOOL", values?: undefined): string;
  encodeFunctionData(functionFragment: "STAKE", values?: undefined): string;
  encodeFunctionData(functionFragment: "SYMBOL", values?: undefined): string;
  encodeFunctionData(functionFragment: "TOKEN", values?: undefined): string;
  encodeFunctionData(functionFragment: "UNDEFINED", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "capitalSupport",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "exists(uint256)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "exists(uint96)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBundleNftId",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getComponentNftId",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "getDip", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getInstanceNftId",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "getNft", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "implementsIStaking",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxRewardRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "mockRegisterRiskpool",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "objects",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rateDecimals",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "registerBundle",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rewardBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setStakedDip",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingRate",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingRate",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "toChain",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalMinted",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "versionParts",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "BUNDLE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "CHAIN", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "EXP", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "INSTANCE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "MULTIPLIER", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "ORACLE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "POLICY", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "PRODUCT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "REGISTRY", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "RISKPOOL", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "STAKE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "SYMBOL", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "TOKEN", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "UNDEFINED", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "capitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exists(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exists(uint96)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBundleNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getComponentNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDip", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getInstanceNftId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNft", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "implementsIStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxRewardRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mockRegisterRiskpool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "objects", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rateDecimals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerBundle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rewardRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakedDip",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "toChain", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "toRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalMinted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "versionParts",
    data: BytesLike
  ): Result;

  events: {
    "LogMockBundleRegistered(uint256,bytes5,uint8,bytes32,uint256,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "LogMockBundleRegistered"): EventFragment;
}

export interface LogMockBundleRegisteredEventObject {
  id: BigNumber;
  chain: string;
  objectType: number;
  instanceId: string;
  riskpoolId: BigNumber;
  bundleId: BigNumber;
  to: string;
}
export type LogMockBundleRegisteredEvent = TypedEvent<
  [BigNumber, string, number, string, BigNumber, BigNumber, string],
  LogMockBundleRegisteredEventObject
>;

export type LogMockBundleRegisteredEventFilter =
  TypedEventFilter<LogMockBundleRegisteredEvent>;

export interface MockRegistryStaking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MockRegistryStakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BUNDLE(overrides?: CallOverrides): Promise<[number]>;

    CHAIN(overrides?: CallOverrides): Promise<[number]>;

    EXP(overrides?: CallOverrides): Promise<[number]>;

    INSTANCE(overrides?: CallOverrides): Promise<[number]>;

    MULTIPLIER(overrides?: CallOverrides): Promise<[BigNumber]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    ORACLE(overrides?: CallOverrides): Promise<[number]>;

    POLICY(overrides?: CallOverrides): Promise<[number]>;

    PRODUCT(overrides?: CallOverrides): Promise<[number]>;

    REGISTRY(overrides?: CallOverrides): Promise<[number]>;

    RISKPOOL(overrides?: CallOverrides): Promise<[number]>;

    STAKE(overrides?: CallOverrides): Promise<[number]>;

    SYMBOL(overrides?: CallOverrides): Promise<[string]>;

    TOKEN(overrides?: CallOverrides): Promise<[number]>;

    UNDEFINED(overrides?: CallOverrides): Promise<[number]>;

    capitalSupport(
      targetNftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { capitalAmount: BigNumber }>;

    "exists(uint256)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    "exists(uint96)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getBundleNftId(
      instanceId: PromiseOrValue<BytesLike>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nftId: BigNumber }>;

    getComponentNftId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nftId: BigNumber }>;

    getDip(overrides?: CallOverrides): Promise<[string]>;

    getInstanceNftId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { id: BigNumber }>;

    getNft(overrides?: CallOverrides): Promise<[string]>;

    getRegistry(overrides?: CallOverrides): Promise<[string]>;

    getStakingWallet(
      overrides?: CallOverrides
    ): Promise<[string] & { stakingWallet: string }>;

    implementsIStaking(overrides?: CallOverrides): Promise<[boolean]>;

    maxRewardRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    mint(
      to: PromiseOrValue<string>,
      uri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mockRegisterRiskpool(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    objects(
      chain: PromiseOrValue<BytesLike>,
      objectType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { numberOfObjects: BigNumber }>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    rateDecimals(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { decimals: BigNumber }>;

    registerBundle(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      displayName: PromiseOrValue<string>,
      expiryAt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    rewardRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    rewardReserves(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    setStakedDip(
      targetNftId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { chain: string }>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    totalMinted(overrides?: CallOverrides): Promise<[BigNumber]>;

    version(overrides?: CallOverrides): Promise<[number]>;

    versionParts(
      overrides?: CallOverrides
    ): Promise<
      [number, number, number] & { major: number; minor: number; patch: number }
    >;
  };

  BUNDLE(overrides?: CallOverrides): Promise<number>;

  CHAIN(overrides?: CallOverrides): Promise<number>;

  EXP(overrides?: CallOverrides): Promise<number>;

  INSTANCE(overrides?: CallOverrides): Promise<number>;

  MULTIPLIER(overrides?: CallOverrides): Promise<BigNumber>;

  NAME(overrides?: CallOverrides): Promise<string>;

  ORACLE(overrides?: CallOverrides): Promise<number>;

  POLICY(overrides?: CallOverrides): Promise<number>;

  PRODUCT(overrides?: CallOverrides): Promise<number>;

  REGISTRY(overrides?: CallOverrides): Promise<number>;

  RISKPOOL(overrides?: CallOverrides): Promise<number>;

  STAKE(overrides?: CallOverrides): Promise<number>;

  SYMBOL(overrides?: CallOverrides): Promise<string>;

  TOKEN(overrides?: CallOverrides): Promise<number>;

  UNDEFINED(overrides?: CallOverrides): Promise<number>;

  capitalSupport(
    targetNftId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "exists(uint256)"(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "exists(uint96)"(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getBundleNftId(
    instanceId: PromiseOrValue<BytesLike>,
    bundleId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getComponentNftId(
    instanceId: PromiseOrValue<BytesLike>,
    componentId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getDip(overrides?: CallOverrides): Promise<string>;

  getInstanceNftId(
    instanceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getNft(overrides?: CallOverrides): Promise<string>;

  getRegistry(overrides?: CallOverrides): Promise<string>;

  getStakingWallet(overrides?: CallOverrides): Promise<string>;

  implementsIStaking(overrides?: CallOverrides): Promise<boolean>;

  maxRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

  mint(
    to: PromiseOrValue<string>,
    uri: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mockRegisterRiskpool(
    instanceId: PromiseOrValue<BytesLike>,
    riskpoolId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  objects(
    chain: PromiseOrValue<BytesLike>,
    objectType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

  registerBundle(
    instanceId: PromiseOrValue<BytesLike>,
    riskpoolId: PromiseOrValue<BigNumberish>,
    bundleId: PromiseOrValue<BigNumberish>,
    displayName: PromiseOrValue<string>,
    expiryAt: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

  rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

  rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

  setStakedDip(
    targetNftId: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingRate(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    rate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakingRate(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  symbol(overrides?: CallOverrides): Promise<string>;

  toChain(
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  toRate(
    value: PromiseOrValue<BigNumberish>,
    exp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalMinted(overrides?: CallOverrides): Promise<BigNumber>;

  version(overrides?: CallOverrides): Promise<number>;

  versionParts(
    overrides?: CallOverrides
  ): Promise<
    [number, number, number] & { major: number; minor: number; patch: number }
  >;

  callStatic: {
    BUNDLE(overrides?: CallOverrides): Promise<number>;

    CHAIN(overrides?: CallOverrides): Promise<number>;

    EXP(overrides?: CallOverrides): Promise<number>;

    INSTANCE(overrides?: CallOverrides): Promise<number>;

    MULTIPLIER(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<string>;

    ORACLE(overrides?: CallOverrides): Promise<number>;

    POLICY(overrides?: CallOverrides): Promise<number>;

    PRODUCT(overrides?: CallOverrides): Promise<number>;

    REGISTRY(overrides?: CallOverrides): Promise<number>;

    RISKPOOL(overrides?: CallOverrides): Promise<number>;

    STAKE(overrides?: CallOverrides): Promise<number>;

    SYMBOL(overrides?: CallOverrides): Promise<string>;

    TOKEN(overrides?: CallOverrides): Promise<number>;

    UNDEFINED(overrides?: CallOverrides): Promise<number>;

    capitalSupport(
      targetNftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "exists(uint256)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "exists(uint96)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getBundleNftId(
      instanceId: PromiseOrValue<BytesLike>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getComponentNftId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDip(overrides?: CallOverrides): Promise<string>;

    getInstanceNftId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNft(overrides?: CallOverrides): Promise<string>;

    getRegistry(overrides?: CallOverrides): Promise<string>;

    getStakingWallet(overrides?: CallOverrides): Promise<string>;

    implementsIStaking(overrides?: CallOverrides): Promise<boolean>;

    maxRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    mint(
      to: PromiseOrValue<string>,
      uri: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mockRegisterRiskpool(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    name(overrides?: CallOverrides): Promise<string>;

    objects(
      chain: PromiseOrValue<BytesLike>,
      objectType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    registerBundle(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      displayName: PromiseOrValue<string>,
      expiryAt: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    setStakedDip(
      targetNftId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<string>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalMinted(overrides?: CallOverrides): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<number>;

    versionParts(
      overrides?: CallOverrides
    ): Promise<
      [number, number, number] & { major: number; minor: number; patch: number }
    >;
  };

  filters: {
    "LogMockBundleRegistered(uint256,bytes5,uint8,bytes32,uint256,uint256,address)"(
      id?: null,
      chain?: null,
      objectType?: null,
      instanceId?: null,
      riskpoolId?: null,
      bundleId?: null,
      to?: null
    ): LogMockBundleRegisteredEventFilter;
    LogMockBundleRegistered(
      id?: null,
      chain?: null,
      objectType?: null,
      instanceId?: null,
      riskpoolId?: null,
      bundleId?: null,
      to?: null
    ): LogMockBundleRegisteredEventFilter;
  };

  estimateGas: {
    BUNDLE(overrides?: CallOverrides): Promise<BigNumber>;

    CHAIN(overrides?: CallOverrides): Promise<BigNumber>;

    EXP(overrides?: CallOverrides): Promise<BigNumber>;

    INSTANCE(overrides?: CallOverrides): Promise<BigNumber>;

    MULTIPLIER(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    ORACLE(overrides?: CallOverrides): Promise<BigNumber>;

    POLICY(overrides?: CallOverrides): Promise<BigNumber>;

    PRODUCT(overrides?: CallOverrides): Promise<BigNumber>;

    REGISTRY(overrides?: CallOverrides): Promise<BigNumber>;

    RISKPOOL(overrides?: CallOverrides): Promise<BigNumber>;

    STAKE(overrides?: CallOverrides): Promise<BigNumber>;

    SYMBOL(overrides?: CallOverrides): Promise<BigNumber>;

    TOKEN(overrides?: CallOverrides): Promise<BigNumber>;

    UNDEFINED(overrides?: CallOverrides): Promise<BigNumber>;

    capitalSupport(
      targetNftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "exists(uint256)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "exists(uint96)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBundleNftId(
      instanceId: PromiseOrValue<BytesLike>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getComponentNftId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDip(overrides?: CallOverrides): Promise<BigNumber>;

    getInstanceNftId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNft(overrides?: CallOverrides): Promise<BigNumber>;

    getRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingWallet(overrides?: CallOverrides): Promise<BigNumber>;

    implementsIStaking(overrides?: CallOverrides): Promise<BigNumber>;

    maxRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    mint(
      to: PromiseOrValue<string>,
      uri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mockRegisterRiskpool(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    objects(
      chain: PromiseOrValue<BytesLike>,
      objectType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    registerBundle(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      displayName: PromiseOrValue<string>,
      expiryAt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    setStakedDip(
      targetNftId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalMinted(overrides?: CallOverrides): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    versionParts(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    BUNDLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    CHAIN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    EXP(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    INSTANCE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MULTIPLIER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ORACLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    POLICY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PRODUCT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    REGISTRY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    RISKPOOL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    STAKE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SYMBOL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UNDEFINED(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    capitalSupport(
      targetNftId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "exists(uint256)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "exists(uint96)"(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBundleNftId(
      instanceId: PromiseOrValue<BytesLike>,
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getComponentNftId(
      instanceId: PromiseOrValue<BytesLike>,
      componentId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDip(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getInstanceNftId(
      instanceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNft(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakingWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    implementsIStaking(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxRewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    mint(
      to: PromiseOrValue<string>,
      uri: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mockRegisterRiskpool(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    objects(
      chain: PromiseOrValue<BytesLike>,
      objectType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rateDecimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    registerBundle(
      instanceId: PromiseOrValue<BytesLike>,
      riskpoolId: PromiseOrValue<BigNumberish>,
      bundleId: PromiseOrValue<BigNumberish>,
      displayName: PromiseOrValue<string>,
      expiryAt: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setStakedDip(
      targetNftId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      rate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalMinted(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    versionParts(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
