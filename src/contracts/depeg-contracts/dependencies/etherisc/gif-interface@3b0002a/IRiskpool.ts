/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace IBundle {
  export type BundleStruct = {
    id: PromiseOrValue<BigNumberish>;
    riskpoolId: PromiseOrValue<BigNumberish>;
    tokenId: PromiseOrValue<BigNumberish>;
    state: PromiseOrValue<BigNumberish>;
    filter: PromiseOrValue<BytesLike>;
    capital: PromiseOrValue<BigNumberish>;
    lockedCapital: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
    updatedAt: PromiseOrValue<BigNumberish>;
  };

  export type BundleStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    id: BigNumber;
    riskpoolId: BigNumber;
    tokenId: BigNumber;
    state: number;
    filter: string;
    capital: BigNumber;
    lockedCapital: BigNumber;
    balance: BigNumber;
    createdAt: BigNumber;
    updatedAt: BigNumber;
  };
}

export declare namespace IPolicy {
  export type ApplicationStruct = {
    state: PromiseOrValue<BigNumberish>;
    premiumAmount: PromiseOrValue<BigNumberish>;
    sumInsuredAmount: PromiseOrValue<BigNumberish>;
    data: PromiseOrValue<BytesLike>;
    createdAt: PromiseOrValue<BigNumberish>;
    updatedAt: PromiseOrValue<BigNumberish>;
  };

  export type ApplicationStructOutput = [
    number,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber
  ] & {
    state: number;
    premiumAmount: BigNumber;
    sumInsuredAmount: BigNumber;
    data: string;
    createdAt: BigNumber;
    updatedAt: BigNumber;
  };
}

export interface IRiskpoolInterface extends utils.Interface {
  functions: {
    "activeBundles()": FunctionFragment;
    "approvalCallback()": FunctionFragment;
    "archiveCallback()": FunctionFragment;
    "bundleMatchesApplication((uint256,uint256,uint256,uint8,bytes,uint256,uint256,uint256,uint256,uint256),(uint8,uint256,uint256,bytes,uint256,uint256))": FunctionFragment;
    "bundles()": FunctionFragment;
    "burnBundle(uint256)": FunctionFragment;
    "closeBundle(uint256)": FunctionFragment;
    "collateralizePolicy(bytes32,uint256)": FunctionFragment;
    "createBundle(bytes,uint256)": FunctionFragment;
    "declineCallback()": FunctionFragment;
    "defundBundle(uint256,uint256)": FunctionFragment;
    "fundBundle(uint256,uint256)": FunctionFragment;
    "getActiveBundleId(uint256)": FunctionFragment;
    "getBalance()": FunctionFragment;
    "getBundle(uint256)": FunctionFragment;
    "getCapacity()": FunctionFragment;
    "getCapital()": FunctionFragment;
    "getCollateralizationLevel()": FunctionFragment;
    "getErc20Token()": FunctionFragment;
    "getFilterDataStructure()": FunctionFragment;
    "getFullCollateralizationLevel()": FunctionFragment;
    "getId()": FunctionFragment;
    "getMaximumNumberOfActiveBundles()": FunctionFragment;
    "getName()": FunctionFragment;
    "getOwner()": FunctionFragment;
    "getRegistry()": FunctionFragment;
    "getState()": FunctionFragment;
    "getSumOfSumInsuredCap()": FunctionFragment;
    "getTotalValueLocked()": FunctionFragment;
    "getType()": FunctionFragment;
    "getWallet()": FunctionFragment;
    "isOracle()": FunctionFragment;
    "isProduct()": FunctionFragment;
    "isRiskpool()": FunctionFragment;
    "lockBundle(uint256)": FunctionFragment;
    "pauseCallback()": FunctionFragment;
    "processPolicyPayout(bytes32,uint256)": FunctionFragment;
    "processPolicyPremium(bytes32,uint256)": FunctionFragment;
    "proposalCallback()": FunctionFragment;
    "releasePolicy(bytes32)": FunctionFragment;
    "resumeCallback()": FunctionFragment;
    "setId(uint256)": FunctionFragment;
    "setMaximumNumberOfActiveBundles(uint256)": FunctionFragment;
    "suspendCallback()": FunctionFragment;
    "unlockBundle(uint256)": FunctionFragment;
    "unpauseCallback()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "activeBundles"
      | "approvalCallback"
      | "archiveCallback"
      | "bundleMatchesApplication"
      | "bundles"
      | "burnBundle"
      | "closeBundle"
      | "collateralizePolicy"
      | "createBundle"
      | "declineCallback"
      | "defundBundle"
      | "fundBundle"
      | "getActiveBundleId"
      | "getBalance"
      | "getBundle"
      | "getCapacity"
      | "getCapital"
      | "getCollateralizationLevel"
      | "getErc20Token"
      | "getFilterDataStructure"
      | "getFullCollateralizationLevel"
      | "getId"
      | "getMaximumNumberOfActiveBundles"
      | "getName"
      | "getOwner"
      | "getRegistry"
      | "getState"
      | "getSumOfSumInsuredCap"
      | "getTotalValueLocked"
      | "getType"
      | "getWallet"
      | "isOracle"
      | "isProduct"
      | "isRiskpool"
      | "lockBundle"
      | "pauseCallback"
      | "processPolicyPayout"
      | "processPolicyPremium"
      | "proposalCallback"
      | "releasePolicy"
      | "resumeCallback"
      | "setId"
      | "setMaximumNumberOfActiveBundles"
      | "suspendCallback"
      | "unlockBundle"
      | "unpauseCallback"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "activeBundles",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approvalCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "archiveCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bundleMatchesApplication",
    values: [IBundle.BundleStruct, IPolicy.ApplicationStruct]
  ): string;
  encodeFunctionData(functionFragment: "bundles", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "burnBundle",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "closeBundle",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralizePolicy",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createBundle",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "declineCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "defundBundle",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fundBundle",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveBundleId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBundle",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapacity",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCapital",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCollateralizationLevel",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getErc20Token",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFilterDataStructure",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFullCollateralizationLevel",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getId", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getMaximumNumberOfActiveBundles",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getName", values?: undefined): string;
  encodeFunctionData(functionFragment: "getOwner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getState", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getSumOfSumInsuredCap",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalValueLocked",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getType", values?: undefined): string;
  encodeFunctionData(functionFragment: "getWallet", values?: undefined): string;
  encodeFunctionData(functionFragment: "isOracle", values?: undefined): string;
  encodeFunctionData(functionFragment: "isProduct", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isRiskpool",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lockBundle",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "pauseCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "processPolicyPayout",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "processPolicyPremium",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "releasePolicy",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "resumeCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaximumNumberOfActiveBundles",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "suspendCallback",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "unlockBundle",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unpauseCallback",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "activeBundles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approvalCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "archiveCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bundleMatchesApplication",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bundles", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burnBundle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "closeBundle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralizePolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createBundle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "declineCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "defundBundle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fundBundle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getActiveBundleId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getBalance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getBundle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCapacity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCapital", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCollateralizationLevel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getErc20Token",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFilterDataStructure",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFullCollateralizationLevel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMaximumNumberOfActiveBundles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getName", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getOwner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getState", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getSumOfSumInsuredCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalValueLocked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getType", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getWallet", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isOracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isProduct", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isRiskpool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lockBundle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pauseCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "processPolicyPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "processPolicyPremium",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releasePolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resumeCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMaximumNumberOfActiveBundles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "suspendCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockBundle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unpauseCallback",
    data: BytesLike
  ): Result;

  events: {
    "LogComponentCreated(bytes32,uint8,address,address)": EventFragment;
    "LogRiskpoolApproved(uint256)": EventFragment;
    "LogRiskpoolBundleCreated(uint256,uint256)": EventFragment;
    "LogRiskpoolBundleMatchesPolicy(uint256,bool)": EventFragment;
    "LogRiskpoolCollateralLocked(bytes32,uint256,bool)": EventFragment;
    "LogRiskpoolCollateralReleased(bytes32,uint256)": EventFragment;
    "LogRiskpoolCreated(address)": EventFragment;
    "LogRiskpoolDeclined(uint256)": EventFragment;
    "LogRiskpoolPayoutProcessed(bytes32,uint256)": EventFragment;
    "LogRiskpoolPremiumProcessed(bytes32,uint256)": EventFragment;
    "LogRiskpoolProposed(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "LogComponentCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRiskpoolApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRiskpoolBundleCreated"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogRiskpoolBundleMatchesPolicy"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogRiskpoolCollateralLocked"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogRiskpoolCollateralReleased"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRiskpoolCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRiskpoolDeclined"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRiskpoolPayoutProcessed"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogRiskpoolPremiumProcessed"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogRiskpoolProposed"): EventFragment;
}

export interface LogComponentCreatedEventObject {
  componentName: string;
  componentType: number;
  componentAddress: string;
  registryAddress: string;
}
export type LogComponentCreatedEvent = TypedEvent<
  [string, number, string, string],
  LogComponentCreatedEventObject
>;

export type LogComponentCreatedEventFilter =
  TypedEventFilter<LogComponentCreatedEvent>;

export interface LogRiskpoolApprovedEventObject {
  id: BigNumber;
}
export type LogRiskpoolApprovedEvent = TypedEvent<
  [BigNumber],
  LogRiskpoolApprovedEventObject
>;

export type LogRiskpoolApprovedEventFilter =
  TypedEventFilter<LogRiskpoolApprovedEvent>;

export interface LogRiskpoolBundleCreatedEventObject {
  bundleId: BigNumber;
  amount: BigNumber;
}
export type LogRiskpoolBundleCreatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  LogRiskpoolBundleCreatedEventObject
>;

export type LogRiskpoolBundleCreatedEventFilter =
  TypedEventFilter<LogRiskpoolBundleCreatedEvent>;

export interface LogRiskpoolBundleMatchesPolicyEventObject {
  bundleId: BigNumber;
  isMatching: boolean;
}
export type LogRiskpoolBundleMatchesPolicyEvent = TypedEvent<
  [BigNumber, boolean],
  LogRiskpoolBundleMatchesPolicyEventObject
>;

export type LogRiskpoolBundleMatchesPolicyEventFilter =
  TypedEventFilter<LogRiskpoolBundleMatchesPolicyEvent>;

export interface LogRiskpoolCollateralLockedEventObject {
  processId: string;
  collateralAmount: BigNumber;
  isSecured: boolean;
}
export type LogRiskpoolCollateralLockedEvent = TypedEvent<
  [string, BigNumber, boolean],
  LogRiskpoolCollateralLockedEventObject
>;

export type LogRiskpoolCollateralLockedEventFilter =
  TypedEventFilter<LogRiskpoolCollateralLockedEvent>;

export interface LogRiskpoolCollateralReleasedEventObject {
  processId: string;
  collateralAmount: BigNumber;
}
export type LogRiskpoolCollateralReleasedEvent = TypedEvent<
  [string, BigNumber],
  LogRiskpoolCollateralReleasedEventObject
>;

export type LogRiskpoolCollateralReleasedEventFilter =
  TypedEventFilter<LogRiskpoolCollateralReleasedEvent>;

export interface LogRiskpoolCreatedEventObject {
  riskpoolAddress: string;
}
export type LogRiskpoolCreatedEvent = TypedEvent<
  [string],
  LogRiskpoolCreatedEventObject
>;

export type LogRiskpoolCreatedEventFilter =
  TypedEventFilter<LogRiskpoolCreatedEvent>;

export interface LogRiskpoolDeclinedEventObject {
  id: BigNumber;
}
export type LogRiskpoolDeclinedEvent = TypedEvent<
  [BigNumber],
  LogRiskpoolDeclinedEventObject
>;

export type LogRiskpoolDeclinedEventFilter =
  TypedEventFilter<LogRiskpoolDeclinedEvent>;

export interface LogRiskpoolPayoutProcessedEventObject {
  processId: string;
  amount: BigNumber;
}
export type LogRiskpoolPayoutProcessedEvent = TypedEvent<
  [string, BigNumber],
  LogRiskpoolPayoutProcessedEventObject
>;

export type LogRiskpoolPayoutProcessedEventFilter =
  TypedEventFilter<LogRiskpoolPayoutProcessedEvent>;

export interface LogRiskpoolPremiumProcessedEventObject {
  processId: string;
  amount: BigNumber;
}
export type LogRiskpoolPremiumProcessedEvent = TypedEvent<
  [string, BigNumber],
  LogRiskpoolPremiumProcessedEventObject
>;

export type LogRiskpoolPremiumProcessedEventFilter =
  TypedEventFilter<LogRiskpoolPremiumProcessedEvent>;

export interface LogRiskpoolProposedEventObject {
  id: BigNumber;
}
export type LogRiskpoolProposedEvent = TypedEvent<
  [BigNumber],
  LogRiskpoolProposedEventObject
>;

export type LogRiskpoolProposedEventFilter =
  TypedEventFilter<LogRiskpoolProposedEvent>;

export interface IRiskpool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IRiskpoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    activeBundles(overrides?: CallOverrides): Promise<[BigNumber]>;

    approvalCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    archiveCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    bundleMatchesApplication(
      bundle: IBundle.BundleStruct,
      application: IPolicy.ApplicationStruct,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isMatching: boolean }>;

    bundles(overrides?: CallOverrides): Promise<[BigNumber]>;

    burnBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    closeBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    collateralizePolicy(
      processId: PromiseOrValue<BytesLike>,
      collateralAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createBundle(
      filter: PromiseOrValue<BytesLike>,
      initialAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    declineCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    defundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getActiveBundleId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { bundleId: BigNumber }>;

    getBalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBundle(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IBundle.BundleStructOutput]>;

    getCapacity(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCapital(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCollateralizationLevel(overrides?: CallOverrides): Promise<[BigNumber]>;

    getErc20Token(overrides?: CallOverrides): Promise<[string]>;

    getFilterDataStructure(overrides?: CallOverrides): Promise<[string]>;

    getFullCollateralizationLevel(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMaximumNumberOfActiveBundles(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { maximumNumberOfActiveBundles: BigNumber }>;

    getName(overrides?: CallOverrides): Promise<[string]>;

    getOwner(overrides?: CallOverrides): Promise<[string]>;

    getRegistry(overrides?: CallOverrides): Promise<[string]>;

    getState(overrides?: CallOverrides): Promise<[number]>;

    getSumOfSumInsuredCap(overrides?: CallOverrides): Promise<[BigNumber]>;

    getTotalValueLocked(overrides?: CallOverrides): Promise<[BigNumber]>;

    getType(overrides?: CallOverrides): Promise<[number]>;

    getWallet(overrides?: CallOverrides): Promise<[string]>;

    isOracle(overrides?: CallOverrides): Promise<[boolean]>;

    isProduct(overrides?: CallOverrides): Promise<[boolean]>;

    isRiskpool(overrides?: CallOverrides): Promise<[boolean]>;

    lockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pauseCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    processPolicyPayout(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    processPolicyPremium(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposalCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    releasePolicy(
      processId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resumeCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setId(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaximumNumberOfActiveBundles(
      maximumNumberOfActiveBundles: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    suspendCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unlockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unpauseCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  activeBundles(overrides?: CallOverrides): Promise<BigNumber>;

  approvalCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  archiveCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  bundleMatchesApplication(
    bundle: IBundle.BundleStruct,
    application: IPolicy.ApplicationStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  bundles(overrides?: CallOverrides): Promise<BigNumber>;

  burnBundle(
    bundleId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  closeBundle(
    bundleId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  collateralizePolicy(
    processId: PromiseOrValue<BytesLike>,
    collateralAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createBundle(
    filter: PromiseOrValue<BytesLike>,
    initialAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  declineCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  defundBundle(
    bundleId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fundBundle(
    bundleId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getActiveBundleId(
    idx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getBalance(overrides?: CallOverrides): Promise<BigNumber>;

  getBundle(
    idx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IBundle.BundleStructOutput>;

  getCapacity(overrides?: CallOverrides): Promise<BigNumber>;

  getCapital(overrides?: CallOverrides): Promise<BigNumber>;

  getCollateralizationLevel(overrides?: CallOverrides): Promise<BigNumber>;

  getErc20Token(overrides?: CallOverrides): Promise<string>;

  getFilterDataStructure(overrides?: CallOverrides): Promise<string>;

  getFullCollateralizationLevel(overrides?: CallOverrides): Promise<BigNumber>;

  getId(overrides?: CallOverrides): Promise<BigNumber>;

  getMaximumNumberOfActiveBundles(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getName(overrides?: CallOverrides): Promise<string>;

  getOwner(overrides?: CallOverrides): Promise<string>;

  getRegistry(overrides?: CallOverrides): Promise<string>;

  getState(overrides?: CallOverrides): Promise<number>;

  getSumOfSumInsuredCap(overrides?: CallOverrides): Promise<BigNumber>;

  getTotalValueLocked(overrides?: CallOverrides): Promise<BigNumber>;

  getType(overrides?: CallOverrides): Promise<number>;

  getWallet(overrides?: CallOverrides): Promise<string>;

  isOracle(overrides?: CallOverrides): Promise<boolean>;

  isProduct(overrides?: CallOverrides): Promise<boolean>;

  isRiskpool(overrides?: CallOverrides): Promise<boolean>;

  lockBundle(
    bundleId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pauseCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  processPolicyPayout(
    processId: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  processPolicyPremium(
    processId: PromiseOrValue<BytesLike>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposalCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  releasePolicy(
    processId: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resumeCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setId(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaximumNumberOfActiveBundles(
    maximumNumberOfActiveBundles: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  suspendCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unlockBundle(
    bundleId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unpauseCallback(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    activeBundles(overrides?: CallOverrides): Promise<BigNumber>;

    approvalCallback(overrides?: CallOverrides): Promise<void>;

    archiveCallback(overrides?: CallOverrides): Promise<void>;

    bundleMatchesApplication(
      bundle: IBundle.BundleStruct,
      application: IPolicy.ApplicationStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    bundles(overrides?: CallOverrides): Promise<BigNumber>;

    burnBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    closeBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    collateralizePolicy(
      processId: PromiseOrValue<BytesLike>,
      collateralAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    createBundle(
      filter: PromiseOrValue<BytesLike>,
      initialAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    declineCallback(overrides?: CallOverrides): Promise<void>;

    defundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getActiveBundleId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getBundle(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IBundle.BundleStructOutput>;

    getCapacity(overrides?: CallOverrides): Promise<BigNumber>;

    getCapital(overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralizationLevel(overrides?: CallOverrides): Promise<BigNumber>;

    getErc20Token(overrides?: CallOverrides): Promise<string>;

    getFilterDataStructure(overrides?: CallOverrides): Promise<string>;

    getFullCollateralizationLevel(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getId(overrides?: CallOverrides): Promise<BigNumber>;

    getMaximumNumberOfActiveBundles(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getName(overrides?: CallOverrides): Promise<string>;

    getOwner(overrides?: CallOverrides): Promise<string>;

    getRegistry(overrides?: CallOverrides): Promise<string>;

    getState(overrides?: CallOverrides): Promise<number>;

    getSumOfSumInsuredCap(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalValueLocked(overrides?: CallOverrides): Promise<BigNumber>;

    getType(overrides?: CallOverrides): Promise<number>;

    getWallet(overrides?: CallOverrides): Promise<string>;

    isOracle(overrides?: CallOverrides): Promise<boolean>;

    isProduct(overrides?: CallOverrides): Promise<boolean>;

    isRiskpool(overrides?: CallOverrides): Promise<boolean>;

    lockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    pauseCallback(overrides?: CallOverrides): Promise<void>;

    processPolicyPayout(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    processPolicyPremium(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    proposalCallback(overrides?: CallOverrides): Promise<void>;

    releasePolicy(
      processId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    resumeCallback(overrides?: CallOverrides): Promise<void>;

    setId(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaximumNumberOfActiveBundles(
      maximumNumberOfActiveBundles: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    suspendCallback(overrides?: CallOverrides): Promise<void>;

    unlockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    unpauseCallback(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "LogComponentCreated(bytes32,uint8,address,address)"(
      componentName?: null,
      componentType?: null,
      componentAddress?: null,
      registryAddress?: null
    ): LogComponentCreatedEventFilter;
    LogComponentCreated(
      componentName?: null,
      componentType?: null,
      componentAddress?: null,
      registryAddress?: null
    ): LogComponentCreatedEventFilter;

    "LogRiskpoolApproved(uint256)"(id?: null): LogRiskpoolApprovedEventFilter;
    LogRiskpoolApproved(id?: null): LogRiskpoolApprovedEventFilter;

    "LogRiskpoolBundleCreated(uint256,uint256)"(
      bundleId?: null,
      amount?: null
    ): LogRiskpoolBundleCreatedEventFilter;
    LogRiskpoolBundleCreated(
      bundleId?: null,
      amount?: null
    ): LogRiskpoolBundleCreatedEventFilter;

    "LogRiskpoolBundleMatchesPolicy(uint256,bool)"(
      bundleId?: null,
      isMatching?: null
    ): LogRiskpoolBundleMatchesPolicyEventFilter;
    LogRiskpoolBundleMatchesPolicy(
      bundleId?: null,
      isMatching?: null
    ): LogRiskpoolBundleMatchesPolicyEventFilter;

    "LogRiskpoolCollateralLocked(bytes32,uint256,bool)"(
      processId?: null,
      collateralAmount?: null,
      isSecured?: null
    ): LogRiskpoolCollateralLockedEventFilter;
    LogRiskpoolCollateralLocked(
      processId?: null,
      collateralAmount?: null,
      isSecured?: null
    ): LogRiskpoolCollateralLockedEventFilter;

    "LogRiskpoolCollateralReleased(bytes32,uint256)"(
      processId?: null,
      collateralAmount?: null
    ): LogRiskpoolCollateralReleasedEventFilter;
    LogRiskpoolCollateralReleased(
      processId?: null,
      collateralAmount?: null
    ): LogRiskpoolCollateralReleasedEventFilter;

    "LogRiskpoolCreated(address)"(
      riskpoolAddress?: null
    ): LogRiskpoolCreatedEventFilter;
    LogRiskpoolCreated(riskpoolAddress?: null): LogRiskpoolCreatedEventFilter;

    "LogRiskpoolDeclined(uint256)"(id?: null): LogRiskpoolDeclinedEventFilter;
    LogRiskpoolDeclined(id?: null): LogRiskpoolDeclinedEventFilter;

    "LogRiskpoolPayoutProcessed(bytes32,uint256)"(
      processId?: null,
      amount?: null
    ): LogRiskpoolPayoutProcessedEventFilter;
    LogRiskpoolPayoutProcessed(
      processId?: null,
      amount?: null
    ): LogRiskpoolPayoutProcessedEventFilter;

    "LogRiskpoolPremiumProcessed(bytes32,uint256)"(
      processId?: null,
      amount?: null
    ): LogRiskpoolPremiumProcessedEventFilter;
    LogRiskpoolPremiumProcessed(
      processId?: null,
      amount?: null
    ): LogRiskpoolPremiumProcessedEventFilter;

    "LogRiskpoolProposed(uint256)"(id?: null): LogRiskpoolProposedEventFilter;
    LogRiskpoolProposed(id?: null): LogRiskpoolProposedEventFilter;
  };

  estimateGas: {
    activeBundles(overrides?: CallOverrides): Promise<BigNumber>;

    approvalCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    archiveCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    bundleMatchesApplication(
      bundle: IBundle.BundleStruct,
      application: IPolicy.ApplicationStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bundles(overrides?: CallOverrides): Promise<BigNumber>;

    burnBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    closeBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    collateralizePolicy(
      processId: PromiseOrValue<BytesLike>,
      collateralAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createBundle(
      filter: PromiseOrValue<BytesLike>,
      initialAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    declineCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    defundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getActiveBundleId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getBundle(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCapacity(overrides?: CallOverrides): Promise<BigNumber>;

    getCapital(overrides?: CallOverrides): Promise<BigNumber>;

    getCollateralizationLevel(overrides?: CallOverrides): Promise<BigNumber>;

    getErc20Token(overrides?: CallOverrides): Promise<BigNumber>;

    getFilterDataStructure(overrides?: CallOverrides): Promise<BigNumber>;

    getFullCollateralizationLevel(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getId(overrides?: CallOverrides): Promise<BigNumber>;

    getMaximumNumberOfActiveBundles(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getName(overrides?: CallOverrides): Promise<BigNumber>;

    getOwner(overrides?: CallOverrides): Promise<BigNumber>;

    getRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    getState(overrides?: CallOverrides): Promise<BigNumber>;

    getSumOfSumInsuredCap(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalValueLocked(overrides?: CallOverrides): Promise<BigNumber>;

    getType(overrides?: CallOverrides): Promise<BigNumber>;

    getWallet(overrides?: CallOverrides): Promise<BigNumber>;

    isOracle(overrides?: CallOverrides): Promise<BigNumber>;

    isProduct(overrides?: CallOverrides): Promise<BigNumber>;

    isRiskpool(overrides?: CallOverrides): Promise<BigNumber>;

    lockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pauseCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    processPolicyPayout(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    processPolicyPremium(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposalCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    releasePolicy(
      processId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resumeCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setId(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaximumNumberOfActiveBundles(
      maximumNumberOfActiveBundles: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    suspendCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unlockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unpauseCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    activeBundles(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approvalCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    archiveCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    bundleMatchesApplication(
      bundle: IBundle.BundleStruct,
      application: IPolicy.ApplicationStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bundles(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    burnBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    closeBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    collateralizePolicy(
      processId: PromiseOrValue<BytesLike>,
      collateralAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createBundle(
      filter: PromiseOrValue<BytesLike>,
      initialAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    declineCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    defundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fundBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getActiveBundleId(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBundle(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCapacity(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCapital(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCollateralizationLevel(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getErc20Token(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getFilterDataStructure(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFullCollateralizationLevel(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMaximumNumberOfActiveBundles(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getName(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getSumOfSumInsuredCap(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalValueLocked(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isOracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isProduct(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isRiskpool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pauseCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    processPolicyPayout(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    processPolicyPremium(
      processId: PromiseOrValue<BytesLike>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposalCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    releasePolicy(
      processId: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resumeCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setId(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaximumNumberOfActiveBundles(
      maximumNumberOfActiveBundles: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    suspendCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unlockBundle(
      bundleId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unpauseCallback(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
