/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IStaking {
  export type StakeInfoStruct = {
    id: PromiseOrValue<BigNumberish>;
    target: PromiseOrValue<BigNumberish>;
    stakeBalance: PromiseOrValue<BigNumberish>;
    rewardBalance: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
    updatedAt: PromiseOrValue<BigNumberish>;
    version: PromiseOrValue<BigNumberish>;
  };

  export type StakeInfoStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number
  ] & {
    id: BigNumber;
    target: BigNumber;
    stakeBalance: BigNumber;
    rewardBalance: BigNumber;
    createdAt: number;
    updatedAt: number;
    version: number;
  };
}

export declare namespace Versionable {
  export type VersionInfoStruct = {
    version: PromiseOrValue<BigNumberish>;
    implementation: PromiseOrValue<string>;
    activatedBy: PromiseOrValue<string>;
    activatedIn: PromiseOrValue<BigNumberish>;
    activatedAt: PromiseOrValue<BigNumberish>;
  };

  export type VersionInfoStructOutput = [
    number,
    string,
    string,
    number,
    number
  ] & {
    version: number;
    implementation: string;
    activatedBy: string;
    activatedIn: number;
    activatedAt: number;
  };
}

export interface StakingV01Interface extends utils.Interface {
  functions: {
    "BUNDLE_LIFETIME_DEFAULT()": FunctionFragment;
    "DIP_CONTRACT_ADDRESS()": FunctionFragment;
    "DIP_DECIMALS()": FunctionFragment;
    "EXP()": FunctionFragment;
    "MAINNET_ID()": FunctionFragment;
    "MAX_REWARD_RATE_EXP()": FunctionFragment;
    "MAX_REWARD_RATE_VALUE()": FunctionFragment;
    "MULTIPLIER()": FunctionFragment;
    "MULTIPLIER_HALF()": FunctionFragment;
    "ROUNDING_DEFAULT()": FunctionFragment;
    "YEAR_DURATION()": FunctionFragment;
    "activate(address)": FunctionFragment;
    "activateAndSetOwner(address,address)": FunctionFragment;
    "blockNumber()": FunctionFragment;
    "calculateCapitalSupport(bytes5,address,uint256)": FunctionFragment;
    "calculateRequiredStaking(bytes5,address,uint256)": FunctionFragment;
    "calculateRewards(uint256,uint256)": FunctionFragment;
    "calculateRewardsIncrement((uint256,uint256,uint256,uint256,uint40,uint40,uint48))": FunctionFragment;
    "capitalSupport(uint256)": FunctionFragment;
    "claimRewards(uint256)": FunctionFragment;
    "createStake(uint256,uint256)": FunctionFragment;
    "decimals()": FunctionFragment;
    "ftoi(uint256,uint8)": FunctionFragment;
    "ftoi(uint256)": FunctionFragment;
    "getBundleInfo(uint256)": FunctionFragment;
    "getBundleState(uint256)": FunctionFragment;
    "getDip()": FunctionFragment;
    "getInfo(uint256)": FunctionFragment;
    "getRegistry()": FunctionFragment;
    "getStakingWallet()": FunctionFragment;
    "getVersion(uint256)": FunctionFragment;
    "getVersionInfo(uint48)": FunctionFragment;
    "intToBytes(uint256,uint8)": FunctionFragment;
    "isActivated(uint48)": FunctionFragment;
    "isStakeOwner(uint256,address)": FunctionFragment;
    "isStakingSupported(uint256)": FunctionFragment;
    "isStakingSupportedForType(uint8)": FunctionFragment;
    "isUnstakingSupported(uint256)": FunctionFragment;
    "itof(uint256)": FunctionFragment;
    "itof(uint256,int8)": FunctionFragment;
    "maxRewardRate()": FunctionFragment;
    "owner()": FunctionFragment;
    "rateDecimals()": FunctionFragment;
    "refillRewardReserves(uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "rewardBalance()": FunctionFragment;
    "rewardRate()": FunctionFragment;
    "rewardReserves()": FunctionFragment;
    "setDipContract(address)": FunctionFragment;
    "setRegistry(address)": FunctionFragment;
    "setRewardRate(uint256)": FunctionFragment;
    "setStakingRate(bytes5,address,uint256)": FunctionFragment;
    "stake(uint256,uint256)": FunctionFragment;
    "stakes(uint256)": FunctionFragment;
    "stakingRate(bytes5,address)": FunctionFragment;
    "toChain(uint256)": FunctionFragment;
    "toInt(bytes5)": FunctionFragment;
    "toInt(uint32)": FunctionFragment;
    "toInt(uint40)": FunctionFragment;
    "toRate(uint256,int8)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "unstake(uint256,uint256)": FunctionFragment;
    "unstakeAndClaimRewards(uint256)": FunctionFragment;
    "version()": FunctionFragment;
    "versionParts()": FunctionFragment;
    "versions()": FunctionFragment;
    "withdrawRewardReserves(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BUNDLE_LIFETIME_DEFAULT"
      | "DIP_CONTRACT_ADDRESS"
      | "DIP_DECIMALS"
      | "EXP"
      | "MAINNET_ID"
      | "MAX_REWARD_RATE_EXP"
      | "MAX_REWARD_RATE_VALUE"
      | "MULTIPLIER"
      | "MULTIPLIER_HALF"
      | "ROUNDING_DEFAULT"
      | "YEAR_DURATION"
      | "activate"
      | "activateAndSetOwner"
      | "blockNumber"
      | "calculateCapitalSupport"
      | "calculateRequiredStaking"
      | "calculateRewards"
      | "calculateRewardsIncrement"
      | "capitalSupport"
      | "claimRewards"
      | "createStake"
      | "decimals"
      | "ftoi(uint256,uint8)"
      | "ftoi(uint256)"
      | "getBundleInfo"
      | "getBundleState"
      | "getDip"
      | "getInfo"
      | "getRegistry"
      | "getStakingWallet"
      | "getVersion"
      | "getVersionInfo"
      | "intToBytes"
      | "isActivated"
      | "isStakeOwner"
      | "isStakingSupported"
      | "isStakingSupportedForType"
      | "isUnstakingSupported"
      | "itof(uint256)"
      | "itof(uint256,int8)"
      | "maxRewardRate"
      | "owner"
      | "rateDecimals"
      | "refillRewardReserves"
      | "renounceOwnership"
      | "rewardBalance"
      | "rewardRate"
      | "rewardReserves"
      | "setDipContract"
      | "setRegistry"
      | "setRewardRate"
      | "setStakingRate"
      | "stake"
      | "stakes"
      | "stakingRate"
      | "toChain"
      | "toInt(bytes5)"
      | "toInt(uint32)"
      | "toInt(uint40)"
      | "toRate"
      | "transferOwnership"
      | "unstake"
      | "unstakeAndClaimRewards"
      | "version"
      | "versionParts"
      | "versions"
      | "withdrawRewardReserves"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "BUNDLE_LIFETIME_DEFAULT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DIP_CONTRACT_ADDRESS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "DIP_DECIMALS",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "EXP", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "MAINNET_ID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_REWARD_RATE_EXP",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_REWARD_RATE_VALUE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MULTIPLIER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MULTIPLIER_HALF",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ROUNDING_DEFAULT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "YEAR_DURATION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "activate",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "activateAndSetOwner",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "blockNumber",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateCapitalSupport",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRequiredStaking",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewards",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewardsIncrement",
    values: [IStaking.StakeInfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "capitalSupport",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRewards",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createStake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ftoi(uint256,uint8)",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "ftoi(uint256)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBundleInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBundleState",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "getDip", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getVersion",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVersionInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "intToBytes",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isActivated",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakeOwner",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakingSupported",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakingSupportedForType",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isUnstakingSupported",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "itof(uint256)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "itof(uint256,int8)",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "maxRewardRate",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rateDecimals",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "refillRewardReserves",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setDipContract",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRegistry",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRewardRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingRate",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingRate",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "toChain",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toInt(bytes5)",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "toInt(uint32)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toInt(uint40)",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstakeAndClaimRewards",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "versionParts",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "versions", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawRewardReserves",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "BUNDLE_LIFETIME_DEFAULT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DIP_CONTRACT_ADDRESS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "DIP_DECIMALS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "EXP", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "MAINNET_ID", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MAX_REWARD_RATE_EXP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_REWARD_RATE_VALUE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MULTIPLIER", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "MULTIPLIER_HALF",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ROUNDING_DEFAULT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "YEAR_DURATION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "activate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "activateAndSetOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "blockNumber",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateCapitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRequiredStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewardsIncrement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "capitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ftoi(uint256,uint8)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ftoi(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBundleInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBundleState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDip", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getVersion", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getVersionInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "intToBytes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isActivated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakingSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakingSupportedForType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUnstakingSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "itof(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "itof(uint256,int8)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxRewardRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rateDecimals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refillRewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rewardRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDipContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRewardRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stakes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "toChain", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "toInt(bytes5)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toInt(uint32)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "toInt(uint40)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "toRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unstakeAndClaimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "versionParts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "versions", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawRewardReserves",
    data: BytesLike
  ): Result;

  events: {
    "Initialized(uint8)": EventFragment;
    "LogStakingNewStake(uint256,address,uint256)": EventFragment;
    "LogStakingRewardRateSet(address,uint256,uint256)": EventFragment;
    "LogStakingRewardReservesDecreased(address,uint256,uint256)": EventFragment;
    "LogStakingRewardReservesIncreased(address,uint256,uint256)": EventFragment;
    "LogStakingRewardsClaimed(uint256,uint256,uint256)": EventFragment;
    "LogStakingRewardsUpdated(uint256,uint256,uint256)": EventFragment;
    "LogStakingStaked(uint256,address,uint256,uint256,uint256)": EventFragment;
    "LogStakingStakingRateSet(address,bytes5,address,uint256,uint256)": EventFragment;
    "LogStakingUnstaked(uint256,address,uint256,uint256,uint256)": EventFragment;
    "LogVersionableActivated(uint48,address,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingNewStake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardRateSet"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogStakingRewardReservesDecreased"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogStakingRewardReservesIncreased"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardsClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingStaked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingStakingRateSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingUnstaked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogVersionableActivated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface LogStakingNewStakeEventObject {
  target: BigNumber;
  user: string;
  id: BigNumber;
}
export type LogStakingNewStakeEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  LogStakingNewStakeEventObject
>;

export type LogStakingNewStakeEventFilter =
  TypedEventFilter<LogStakingNewStakeEvent>;

export interface LogStakingRewardRateSetEventObject {
  user: string;
  oldRewardRate: BigNumber;
  newRewardRate: BigNumber;
}
export type LogStakingRewardRateSetEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardRateSetEventObject
>;

export type LogStakingRewardRateSetEventFilter =
  TypedEventFilter<LogStakingRewardRateSetEvent>;

export interface LogStakingRewardReservesDecreasedEventObject {
  user: string;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardReservesDecreasedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardReservesDecreasedEventObject
>;

export type LogStakingRewardReservesDecreasedEventFilter =
  TypedEventFilter<LogStakingRewardReservesDecreasedEvent>;

export interface LogStakingRewardReservesIncreasedEventObject {
  user: string;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardReservesIncreasedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardReservesIncreasedEventObject
>;

export type LogStakingRewardReservesIncreasedEventFilter =
  TypedEventFilter<LogStakingRewardReservesIncreasedEvent>;

export interface LogStakingRewardsClaimedEventObject {
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardsClaimedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  LogStakingRewardsClaimedEventObject
>;

export type LogStakingRewardsClaimedEventFilter =
  TypedEventFilter<LogStakingRewardsClaimedEvent>;

export interface LogStakingRewardsUpdatedEventObject {
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardsUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  LogStakingRewardsUpdatedEventObject
>;

export type LogStakingRewardsUpdatedEventFilter =
  TypedEventFilter<LogStakingRewardsUpdatedEvent>;

export interface LogStakingStakedEventObject {
  target: BigNumber;
  user: string;
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingStakedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber, BigNumber],
  LogStakingStakedEventObject
>;

export type LogStakingStakedEventFilter =
  TypedEventFilter<LogStakingStakedEvent>;

export interface LogStakingStakingRateSetEventObject {
  user: string;
  chain: string;
  token: string;
  oldStakingRate: BigNumber;
  newStakingRate: BigNumber;
}
export type LogStakingStakingRateSetEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  LogStakingStakingRateSetEventObject
>;

export type LogStakingStakingRateSetEventFilter =
  TypedEventFilter<LogStakingStakingRateSetEvent>;

export interface LogStakingUnstakedEventObject {
  target: BigNumber;
  user: string;
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingUnstakedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber, BigNumber],
  LogStakingUnstakedEventObject
>;

export type LogStakingUnstakedEventFilter =
  TypedEventFilter<LogStakingUnstakedEvent>;

export interface LogVersionableActivatedEventObject {
  version: number;
  implementation: string;
  activatedBy: string;
}
export type LogVersionableActivatedEvent = TypedEvent<
  [number, string, string],
  LogVersionableActivatedEventObject
>;

export type LogVersionableActivatedEventFilter =
  TypedEventFilter<LogVersionableActivatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface StakingV01 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: StakingV01Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BUNDLE_LIFETIME_DEFAULT(overrides?: CallOverrides): Promise<[BigNumber]>;

    DIP_CONTRACT_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    DIP_DECIMALS(overrides?: CallOverrides): Promise<[BigNumber]>;

    EXP(overrides?: CallOverrides): Promise<[number]>;

    MAINNET_ID(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_REWARD_RATE_EXP(overrides?: CallOverrides): Promise<[number]>;

    MAX_REWARD_RATE_VALUE(overrides?: CallOverrides): Promise<[BigNumber]>;

    MULTIPLIER(overrides?: CallOverrides): Promise<[BigNumber]>;

    MULTIPLIER_HALF(overrides?: CallOverrides): Promise<[BigNumber]>;

    ROUNDING_DEFAULT(overrides?: CallOverrides): Promise<[number]>;

    YEAR_DURATION(overrides?: CallOverrides): Promise<[BigNumber]>;

    activate(
      implementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    activateAndSetOwner(
      implementation: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    blockNumber(overrides?: CallOverrides): Promise<[number]>;

    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { tokenAmount: BigNumber }>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardAmount: BigNumber }>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardsAmount: BigNumber }>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { capitalAmount: BigNumber }>;

    claimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    decimals(overrides?: CallOverrides): Promise<[BigNumber]>;

    "ftoi(uint256,uint8)"(
      a: PromiseOrValue<BigNumberish>,
      rounding: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "ftoi(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getBundleInfo(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        string,
        number,
        number,
        BigNumber,
        BigNumber
      ] & {
        instanceId: string;
        riskpoolId: BigNumber;
        bundleId: BigNumber;
        displayName: string;
        bundleState: number;
        expiryAt: number;
        stakeAmount: BigNumber;
        rewardAmount: BigNumber;
      }
    >;

    getBundleState(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, number, number] & {
        objectState: number;
        bundleState: number;
        expiryAt: number;
      }
    >;

    getDip(overrides?: CallOverrides): Promise<[string] & { dip: string }>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IStaking.StakeInfoStructOutput] & {
        info: IStaking.StakeInfoStructOutput;
      }
    >;

    getRegistry(overrides?: CallOverrides): Promise<[string]>;

    getStakingWallet(
      overrides?: CallOverrides
    ): Promise<[string] & { stakingWallet: string }>;

    getVersion(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    getVersionInfo(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[Versionable.VersionInfoStructOutput]>;

    intToBytes(
      x: PromiseOrValue<BigNumberish>,
      shift: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    isActivated(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isStakeOwner(
      stakeId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isOwner: boolean }>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    "itof(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "itof(uint256,int8)"(
      a: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    maxRewardRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    rateDecimals(overrides?: CallOverrides): Promise<[BigNumber]>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dips: BigNumber }>;

    rewardRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    rewardReserves(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dips: BigNumber }>;

    setDipContract(
      dipToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRegistry(
      registry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRewardRate(
      newRewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      newStakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stake(
      stakeId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rate: BigNumber }>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "toInt(bytes5)"(
      x: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "toInt(uint32)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "toInt(uint40)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unstake(
      stakeId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unstakeAndClaimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    version(overrides?: CallOverrides): Promise<[number]>;

    versionParts(
      overrides?: CallOverrides
    ): Promise<
      [number, number, number] & { major: number; minor: number; patch: number }
    >;

    versions(overrides?: CallOverrides): Promise<[BigNumber]>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  BUNDLE_LIFETIME_DEFAULT(overrides?: CallOverrides): Promise<BigNumber>;

  DIP_CONTRACT_ADDRESS(overrides?: CallOverrides): Promise<string>;

  DIP_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

  EXP(overrides?: CallOverrides): Promise<number>;

  MAINNET_ID(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_REWARD_RATE_EXP(overrides?: CallOverrides): Promise<number>;

  MAX_REWARD_RATE_VALUE(overrides?: CallOverrides): Promise<BigNumber>;

  MULTIPLIER(overrides?: CallOverrides): Promise<BigNumber>;

  MULTIPLIER_HALF(overrides?: CallOverrides): Promise<BigNumber>;

  ROUNDING_DEFAULT(overrides?: CallOverrides): Promise<number>;

  YEAR_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

  activate(
    implementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  activateAndSetOwner(
    implementation: PromiseOrValue<string>,
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  blockNumber(overrides?: CallOverrides): Promise<number>;

  calculateCapitalSupport(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRequiredStaking(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    tokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRewards(
    amount: PromiseOrValue<BigNumberish>,
    duration: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRewardsIncrement(
    stakeInfo: IStaking.StakeInfoStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  capitalSupport(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimRewards(
    stakeId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createStake(
    target: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  decimals(overrides?: CallOverrides): Promise<BigNumber>;

  "ftoi(uint256,uint8)"(
    a: PromiseOrValue<BigNumberish>,
    rounding: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "ftoi(uint256)"(
    a: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getBundleInfo(
    stakeId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      BigNumber,
      BigNumber,
      string,
      number,
      number,
      BigNumber,
      BigNumber
    ] & {
      instanceId: string;
      riskpoolId: BigNumber;
      bundleId: BigNumber;
      displayName: string;
      bundleState: number;
      expiryAt: number;
      stakeAmount: BigNumber;
      rewardAmount: BigNumber;
    }
  >;

  getBundleState(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [number, number, number] & {
      objectState: number;
      bundleState: number;
      expiryAt: number;
    }
  >;

  getDip(overrides?: CallOverrides): Promise<string>;

  getInfo(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IStaking.StakeInfoStructOutput>;

  getRegistry(overrides?: CallOverrides): Promise<string>;

  getStakingWallet(overrides?: CallOverrides): Promise<string>;

  getVersion(
    idx: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  getVersionInfo(
    _version: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<Versionable.VersionInfoStructOutput>;

  intToBytes(
    x: PromiseOrValue<BigNumberish>,
    shift: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  isActivated(
    _version: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStakeOwner(
    stakeId: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStakingSupported(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStakingSupportedForType(
    targetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isUnstakingSupported(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "itof(uint256)"(
    a: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "itof(uint256,int8)"(
    a: PromiseOrValue<BigNumberish>,
    exp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  maxRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

  refillRewardReserves(
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

  rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

  rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

  setDipContract(
    dipToken: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRegistry(
    registry: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRewardRate(
    newRewardRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingRate(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    newStakingRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stake(
    stakeId: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakes(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  stakingRate(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  toChain(
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  "toInt(bytes5)"(
    x: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "toInt(uint32)"(
    x: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "toInt(uint40)"(
    x: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  toRate(
    value: PromiseOrValue<BigNumberish>,
    exp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unstake(
    stakeId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unstakeAndClaimRewards(
    stakeId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  version(overrides?: CallOverrides): Promise<number>;

  versionParts(
    overrides?: CallOverrides
  ): Promise<
    [number, number, number] & { major: number; minor: number; patch: number }
  >;

  versions(overrides?: CallOverrides): Promise<BigNumber>;

  withdrawRewardReserves(
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    BUNDLE_LIFETIME_DEFAULT(overrides?: CallOverrides): Promise<BigNumber>;

    DIP_CONTRACT_ADDRESS(overrides?: CallOverrides): Promise<string>;

    DIP_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    EXP(overrides?: CallOverrides): Promise<number>;

    MAINNET_ID(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_REWARD_RATE_EXP(overrides?: CallOverrides): Promise<number>;

    MAX_REWARD_RATE_VALUE(overrides?: CallOverrides): Promise<BigNumber>;

    MULTIPLIER(overrides?: CallOverrides): Promise<BigNumber>;

    MULTIPLIER_HALF(overrides?: CallOverrides): Promise<BigNumber>;

    ROUNDING_DEFAULT(overrides?: CallOverrides): Promise<number>;

    YEAR_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    activate(
      implementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    activateAndSetOwner(
      implementation: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    blockNumber(overrides?: CallOverrides): Promise<number>;

    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    "ftoi(uint256,uint8)"(
      a: PromiseOrValue<BigNumberish>,
      rounding: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "ftoi(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBundleInfo(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        string,
        number,
        number,
        BigNumber,
        BigNumber
      ] & {
        instanceId: string;
        riskpoolId: BigNumber;
        bundleId: BigNumber;
        displayName: string;
        bundleState: number;
        expiryAt: number;
        stakeAmount: BigNumber;
        rewardAmount: BigNumber;
      }
    >;

    getBundleState(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, number, number] & {
        objectState: number;
        bundleState: number;
        expiryAt: number;
      }
    >;

    getDip(overrides?: CallOverrides): Promise<string>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IStaking.StakeInfoStructOutput>;

    getRegistry(overrides?: CallOverrides): Promise<string>;

    getStakingWallet(overrides?: CallOverrides): Promise<string>;

    getVersion(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    getVersionInfo(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<Versionable.VersionInfoStructOutput>;

    intToBytes(
      x: PromiseOrValue<BigNumberish>,
      shift: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    isActivated(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStakeOwner(
      stakeId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "itof(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "itof(uint256,int8)"(
      a: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    setDipContract(
      dipToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRegistry(
      registry: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRewardRate(
      newRewardRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      newStakingRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      stakeId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    "toInt(bytes5)"(
      x: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "toInt(uint32)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "toInt(uint40)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unstake(
      stakeId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    unstakeAndClaimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    version(overrides?: CallOverrides): Promise<number>;

    versionParts(
      overrides?: CallOverrides
    ): Promise<
      [number, number, number] & { major: number; minor: number; patch: number }
    >;

    versions(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "LogStakingNewStake(uint256,address,uint256)"(
      target?: null,
      user?: null,
      id?: null
    ): LogStakingNewStakeEventFilter;
    LogStakingNewStake(
      target?: null,
      user?: null,
      id?: null
    ): LogStakingNewStakeEventFilter;

    "LogStakingRewardRateSet(address,uint256,uint256)"(
      user?: null,
      oldRewardRate?: null,
      newRewardRate?: null
    ): LogStakingRewardRateSetEventFilter;
    LogStakingRewardRateSet(
      user?: null,
      oldRewardRate?: null,
      newRewardRate?: null
    ): LogStakingRewardRateSetEventFilter;

    "LogStakingRewardReservesDecreased(address,uint256,uint256)"(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesDecreasedEventFilter;
    LogStakingRewardReservesDecreased(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesDecreasedEventFilter;

    "LogStakingRewardReservesIncreased(address,uint256,uint256)"(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesIncreasedEventFilter;
    LogStakingRewardReservesIncreased(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesIncreasedEventFilter;

    "LogStakingRewardsClaimed(uint256,uint256,uint256)"(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsClaimedEventFilter;
    LogStakingRewardsClaimed(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsClaimedEventFilter;

    "LogStakingRewardsUpdated(uint256,uint256,uint256)"(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsUpdatedEventFilter;
    LogStakingRewardsUpdated(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsUpdatedEventFilter;

    "LogStakingStaked(uint256,address,uint256,uint256,uint256)"(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingStakedEventFilter;
    LogStakingStaked(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingStakedEventFilter;

    "LogStakingStakingRateSet(address,bytes5,address,uint256,uint256)"(
      user?: null,
      chain?: null,
      token?: null,
      oldStakingRate?: null,
      newStakingRate?: null
    ): LogStakingStakingRateSetEventFilter;
    LogStakingStakingRateSet(
      user?: null,
      chain?: null,
      token?: null,
      oldStakingRate?: null,
      newStakingRate?: null
    ): LogStakingStakingRateSetEventFilter;

    "LogStakingUnstaked(uint256,address,uint256,uint256,uint256)"(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingUnstakedEventFilter;
    LogStakingUnstaked(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingUnstakedEventFilter;

    "LogVersionableActivated(uint48,address,address)"(
      version?: null,
      implementation?: null,
      activatedBy?: null
    ): LogVersionableActivatedEventFilter;
    LogVersionableActivated(
      version?: null,
      implementation?: null,
      activatedBy?: null
    ): LogVersionableActivatedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    BUNDLE_LIFETIME_DEFAULT(overrides?: CallOverrides): Promise<BigNumber>;

    DIP_CONTRACT_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    DIP_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    EXP(overrides?: CallOverrides): Promise<BigNumber>;

    MAINNET_ID(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_REWARD_RATE_EXP(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_REWARD_RATE_VALUE(overrides?: CallOverrides): Promise<BigNumber>;

    MULTIPLIER(overrides?: CallOverrides): Promise<BigNumber>;

    MULTIPLIER_HALF(overrides?: CallOverrides): Promise<BigNumber>;

    ROUNDING_DEFAULT(overrides?: CallOverrides): Promise<BigNumber>;

    YEAR_DURATION(overrides?: CallOverrides): Promise<BigNumber>;

    activate(
      implementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    activateAndSetOwner(
      implementation: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    blockNumber(overrides?: CallOverrides): Promise<BigNumber>;

    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    "ftoi(uint256,uint8)"(
      a: PromiseOrValue<BigNumberish>,
      rounding: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "ftoi(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBundleInfo(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBundleState(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDip(overrides?: CallOverrides): Promise<BigNumber>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingWallet(overrides?: CallOverrides): Promise<BigNumber>;

    getVersion(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVersionInfo(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    intToBytes(
      x: PromiseOrValue<BigNumberish>,
      shift: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isActivated(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStakeOwner(
      stakeId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "itof(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "itof(uint256,int8)"(
      a: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    maxRewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    setDipContract(
      dipToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRegistry(
      registry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRewardRate(
      newRewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      newStakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stake(
      stakeId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "toInt(bytes5)"(
      x: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "toInt(uint32)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "toInt(uint40)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unstake(
      stakeId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unstakeAndClaimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    versionParts(overrides?: CallOverrides): Promise<BigNumber>;

    versions(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BUNDLE_LIFETIME_DEFAULT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DIP_CONTRACT_ADDRESS(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    DIP_DECIMALS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    EXP(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAINNET_ID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_REWARD_RATE_EXP(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MAX_REWARD_RATE_VALUE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MULTIPLIER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MULTIPLIER_HALF(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ROUNDING_DEFAULT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    YEAR_DURATION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    activate(
      implementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    activateAndSetOwner(
      implementation: PromiseOrValue<string>,
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    blockNumber(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "ftoi(uint256,uint8)"(
      a: PromiseOrValue<BigNumberish>,
      rounding: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "ftoi(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBundleInfo(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBundleState(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDip(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakingWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getVersion(
      idx: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVersionInfo(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    intToBytes(
      x: PromiseOrValue<BigNumberish>,
      shift: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isActivated(
      _version: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakeOwner(
      stakeId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "itof(uint256)"(
      a: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "itof(uint256,int8)"(
      a: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    maxRewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rateDecimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setDipContract(
      dipToken: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRegistry(
      registry: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRewardRate(
      newRewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      newStakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      stakeId: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "toInt(bytes5)"(
      x: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "toInt(uint32)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "toInt(uint40)"(
      x: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unstake(
      stakeId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unstakeAndClaimRewards(
      stakeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    versionParts(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    versions(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
