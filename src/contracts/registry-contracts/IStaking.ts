/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IStaking {
  export type StakeInfoStruct = {
    id: PromiseOrValue<BigNumberish>;
    target: PromiseOrValue<BigNumberish>;
    stakeBalance: PromiseOrValue<BigNumberish>;
    rewardBalance: PromiseOrValue<BigNumberish>;
    createdAt: PromiseOrValue<BigNumberish>;
    updatedAt: PromiseOrValue<BigNumberish>;
    version: PromiseOrValue<BigNumberish>;
  };

  export type StakeInfoStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number
  ] & {
    id: BigNumber;
    target: BigNumber;
    stakeBalance: BigNumber;
    rewardBalance: BigNumber;
    createdAt: number;
    updatedAt: number;
    version: number;
  };
}

export interface IStakingInterface extends utils.Interface {
  functions: {
    "calculateCapitalSupport(bytes5,address,uint256)": FunctionFragment;
    "calculateRequiredStaking(bytes5,address,uint256)": FunctionFragment;
    "calculateRewards(uint256,uint256)": FunctionFragment;
    "calculateRewardsIncrement((uint96,uint96,uint256,uint256,uint40,uint40,uint48))": FunctionFragment;
    "capitalSupport(uint96)": FunctionFragment;
    "claimRewards(uint96)": FunctionFragment;
    "createStake(uint96,uint256)": FunctionFragment;
    "getBundleInfo(uint96)": FunctionFragment;
    "getDip()": FunctionFragment;
    "getInfo(uint96)": FunctionFragment;
    "getRegistry()": FunctionFragment;
    "getStakingWallet()": FunctionFragment;
    "implementsIStaking()": FunctionFragment;
    "isStakeOwner(uint96,address)": FunctionFragment;
    "isStakingSupported(uint96)": FunctionFragment;
    "isStakingSupportedForType(uint8)": FunctionFragment;
    "isUnstakingSupported(uint96)": FunctionFragment;
    "rateDecimals()": FunctionFragment;
    "refillRewardReserves(uint256)": FunctionFragment;
    "rewardBalance()": FunctionFragment;
    "rewardRate()": FunctionFragment;
    "rewardReserves()": FunctionFragment;
    "setRewardRate(uint256)": FunctionFragment;
    "setStakingRate(bytes5,address,uint256)": FunctionFragment;
    "stake(uint96,uint256)": FunctionFragment;
    "stakes(uint96)": FunctionFragment;
    "stakingRate(bytes5,address)": FunctionFragment;
    "toChain(uint256)": FunctionFragment;
    "toRate(uint256,int8)": FunctionFragment;
    "unstake(uint96,uint256)": FunctionFragment;
    "unstakeAndClaimRewards(uint96)": FunctionFragment;
    "withdrawRewardReserves(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "calculateCapitalSupport"
      | "calculateRequiredStaking"
      | "calculateRewards"
      | "calculateRewardsIncrement"
      | "capitalSupport"
      | "claimRewards"
      | "createStake"
      | "getBundleInfo"
      | "getDip"
      | "getInfo"
      | "getRegistry"
      | "getStakingWallet"
      | "implementsIStaking"
      | "isStakeOwner"
      | "isStakingSupported"
      | "isStakingSupportedForType"
      | "isUnstakingSupported"
      | "rateDecimals"
      | "refillRewardReserves"
      | "rewardBalance"
      | "rewardRate"
      | "rewardReserves"
      | "setRewardRate"
      | "setStakingRate"
      | "stake"
      | "stakes"
      | "stakingRate"
      | "toChain"
      | "toRate"
      | "unstake"
      | "unstakeAndClaimRewards"
      | "withdrawRewardReserves"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "calculateCapitalSupport",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRequiredStaking",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewards",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewardsIncrement",
    values: [IStaking.StakeInfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "capitalSupport",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRewards",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "createStake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBundleInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "getDip", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "implementsIStaking",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isStakeOwner",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakingSupported",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isStakingSupportedForType",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isUnstakingSupported",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "rateDecimals",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "refillRewardReserves",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "rewardBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setRewardRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakingRate",
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakes",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakingRate",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "toChain",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "toRate",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unstakeAndClaimRewards",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawRewardReserves",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "calculateCapitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRequiredStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewardsIncrement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "capitalSupport",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBundleInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDip", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "implementsIStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakeOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakingSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isStakingSupportedForType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUnstakingSupported",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rateDecimals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refillRewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rewardRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rewardReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRewardRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stakes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "toChain", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "toRate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unstakeAndClaimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawRewardReserves",
    data: BytesLike
  ): Result;

  events: {
    "LogStakingNewStakeCreated(uint96,address,uint96)": EventFragment;
    "LogStakingRewardRateSet(address,uint256,uint256)": EventFragment;
    "LogStakingRewardReservesDecreased(address,uint256,uint256)": EventFragment;
    "LogStakingRewardReservesIncreased(address,uint256,uint256)": EventFragment;
    "LogStakingRewardsClaimed(uint96,uint256,uint256)": EventFragment;
    "LogStakingRewardsUpdated(uint96,uint256,uint256)": EventFragment;
    "LogStakingStaked(uint96,address,uint96,uint256,uint256)": EventFragment;
    "LogStakingStakingRateSet(address,bytes5,address,uint256,uint256)": EventFragment;
    "LogStakingUnstaked(uint96,address,uint96,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "LogStakingNewStakeCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardRateSet"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogStakingRewardReservesDecreased"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "LogStakingRewardReservesIncreased"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardsClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingRewardsUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingStaked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingStakingRateSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogStakingUnstaked"): EventFragment;
}

export interface LogStakingNewStakeCreatedEventObject {
  target: BigNumber;
  user: string;
  id: BigNumber;
}
export type LogStakingNewStakeCreatedEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  LogStakingNewStakeCreatedEventObject
>;

export type LogStakingNewStakeCreatedEventFilter =
  TypedEventFilter<LogStakingNewStakeCreatedEvent>;

export interface LogStakingRewardRateSetEventObject {
  user: string;
  oldRewardRate: BigNumber;
  newRewardRate: BigNumber;
}
export type LogStakingRewardRateSetEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardRateSetEventObject
>;

export type LogStakingRewardRateSetEventFilter =
  TypedEventFilter<LogStakingRewardRateSetEvent>;

export interface LogStakingRewardReservesDecreasedEventObject {
  user: string;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardReservesDecreasedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardReservesDecreasedEventObject
>;

export type LogStakingRewardReservesDecreasedEventFilter =
  TypedEventFilter<LogStakingRewardReservesDecreasedEvent>;

export interface LogStakingRewardReservesIncreasedEventObject {
  user: string;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardReservesIncreasedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  LogStakingRewardReservesIncreasedEventObject
>;

export type LogStakingRewardReservesIncreasedEventFilter =
  TypedEventFilter<LogStakingRewardReservesIncreasedEvent>;

export interface LogStakingRewardsClaimedEventObject {
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardsClaimedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  LogStakingRewardsClaimedEventObject
>;

export type LogStakingRewardsClaimedEventFilter =
  TypedEventFilter<LogStakingRewardsClaimedEvent>;

export interface LogStakingRewardsUpdatedEventObject {
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingRewardsUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  LogStakingRewardsUpdatedEventObject
>;

export type LogStakingRewardsUpdatedEventFilter =
  TypedEventFilter<LogStakingRewardsUpdatedEvent>;

export interface LogStakingStakedEventObject {
  target: BigNumber;
  user: string;
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingStakedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber, BigNumber],
  LogStakingStakedEventObject
>;

export type LogStakingStakedEventFilter =
  TypedEventFilter<LogStakingStakedEvent>;

export interface LogStakingStakingRateSetEventObject {
  user: string;
  chain: string;
  token: string;
  oldStakingRate: BigNumber;
  newStakingRate: BigNumber;
}
export type LogStakingStakingRateSetEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  LogStakingStakingRateSetEventObject
>;

export type LogStakingStakingRateSetEventFilter =
  TypedEventFilter<LogStakingStakingRateSetEvent>;

export interface LogStakingUnstakedEventObject {
  target: BigNumber;
  user: string;
  id: BigNumber;
  amount: BigNumber;
  newBalance: BigNumber;
}
export type LogStakingUnstakedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber, BigNumber],
  LogStakingUnstakedEventObject
>;

export type LogStakingUnstakedEventFilter =
  TypedEventFilter<LogStakingUnstakedEvent>;

export interface IStaking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IStakingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { tokenAmount: BigNumber }>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardAmount: BigNumber }>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardsAmount: BigNumber }>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { capitalAmount: BigNumber }>;

    claimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getBundleInfo(
      bundle: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        number,
        number,
        boolean,
        boolean,
        BigNumber
      ] & {
        instanceId: string;
        riskpoolId: BigNumber;
        bundleId: BigNumber;
        token: string;
        displayName: string;
        bundleState: number;
        expiryAt: number;
        stakingSupported: boolean;
        unstakingSupported: boolean;
        stakeBalance: BigNumber;
      }
    >;

    getDip(overrides?: CallOverrides): Promise<[string]>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IStaking.StakeInfoStructOutput] & {
        info: IStaking.StakeInfoStructOutput;
      }
    >;

    getRegistry(overrides?: CallOverrides): Promise<[string]>;

    getStakingWallet(
      overrides?: CallOverrides
    ): Promise<[string] & { stakingWallet: string }>;

    implementsIStaking(overrides?: CallOverrides): Promise<[boolean]>;

    isStakeOwner(
      id: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isOwner: boolean }>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isSupported: boolean }>;

    rateDecimals(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { decimals: BigNumber }>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    rewardRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardRate: BigNumber }>;

    rewardReserves(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { dipAmount: BigNumber }>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { stakingRate: BigNumber }>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    unstake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unstakeAndClaimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  calculateCapitalSupport(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRequiredStaking(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    tokenAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRewards(
    amount: PromiseOrValue<BigNumberish>,
    duration: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  calculateRewardsIncrement(
    stakeInfo: IStaking.StakeInfoStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  capitalSupport(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimRewards(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createStake(
    target: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getBundleInfo(
    bundle: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      BigNumber,
      BigNumber,
      string,
      string,
      number,
      number,
      boolean,
      boolean,
      BigNumber
    ] & {
      instanceId: string;
      riskpoolId: BigNumber;
      bundleId: BigNumber;
      token: string;
      displayName: string;
      bundleState: number;
      expiryAt: number;
      stakingSupported: boolean;
      unstakingSupported: boolean;
      stakeBalance: BigNumber;
    }
  >;

  getDip(overrides?: CallOverrides): Promise<string>;

  getInfo(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IStaking.StakeInfoStructOutput>;

  getRegistry(overrides?: CallOverrides): Promise<string>;

  getStakingWallet(overrides?: CallOverrides): Promise<string>;

  implementsIStaking(overrides?: CallOverrides): Promise<boolean>;

  isStakeOwner(
    id: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStakingSupported(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isStakingSupportedForType(
    targetType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isUnstakingSupported(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

  refillRewardReserves(
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

  rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

  rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

  setRewardRate(
    rewardRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setStakingRate(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    stakingRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stake(
    id: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakes(
    target: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  stakingRate(
    chain: PromiseOrValue<BytesLike>,
    token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  toChain(
    chainId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  toRate(
    value: PromiseOrValue<BigNumberish>,
    exp: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  unstake(
    id: PromiseOrValue<BigNumberish>,
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unstakeAndClaimRewards(
    id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawRewardReserves(
    dipAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBundleInfo(
      bundle: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        number,
        number,
        boolean,
        boolean,
        BigNumber
      ] & {
        instanceId: string;
        riskpoolId: BigNumber;
        bundleId: BigNumber;
        token: string;
        displayName: string;
        bundleState: number;
        expiryAt: number;
        stakingSupported: boolean;
        unstakingSupported: boolean;
        stakeBalance: BigNumber;
      }
    >;

    getDip(overrides?: CallOverrides): Promise<string>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IStaking.StakeInfoStructOutput>;

    getRegistry(overrides?: CallOverrides): Promise<string>;

    getStakingWallet(overrides?: CallOverrides): Promise<string>;

    implementsIStaking(overrides?: CallOverrides): Promise<boolean>;

    isStakeOwner(
      id: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    unstakeAndClaimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "LogStakingNewStakeCreated(uint96,address,uint96)"(
      target?: null,
      user?: null,
      id?: null
    ): LogStakingNewStakeCreatedEventFilter;
    LogStakingNewStakeCreated(
      target?: null,
      user?: null,
      id?: null
    ): LogStakingNewStakeCreatedEventFilter;

    "LogStakingRewardRateSet(address,uint256,uint256)"(
      user?: null,
      oldRewardRate?: null,
      newRewardRate?: null
    ): LogStakingRewardRateSetEventFilter;
    LogStakingRewardRateSet(
      user?: null,
      oldRewardRate?: null,
      newRewardRate?: null
    ): LogStakingRewardRateSetEventFilter;

    "LogStakingRewardReservesDecreased(address,uint256,uint256)"(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesDecreasedEventFilter;
    LogStakingRewardReservesDecreased(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesDecreasedEventFilter;

    "LogStakingRewardReservesIncreased(address,uint256,uint256)"(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesIncreasedEventFilter;
    LogStakingRewardReservesIncreased(
      user?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardReservesIncreasedEventFilter;

    "LogStakingRewardsClaimed(uint96,uint256,uint256)"(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsClaimedEventFilter;
    LogStakingRewardsClaimed(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsClaimedEventFilter;

    "LogStakingRewardsUpdated(uint96,uint256,uint256)"(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsUpdatedEventFilter;
    LogStakingRewardsUpdated(
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingRewardsUpdatedEventFilter;

    "LogStakingStaked(uint96,address,uint96,uint256,uint256)"(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingStakedEventFilter;
    LogStakingStaked(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingStakedEventFilter;

    "LogStakingStakingRateSet(address,bytes5,address,uint256,uint256)"(
      user?: null,
      chain?: null,
      token?: null,
      oldStakingRate?: null,
      newStakingRate?: null
    ): LogStakingStakingRateSetEventFilter;
    LogStakingStakingRateSet(
      user?: null,
      chain?: null,
      token?: null,
      oldStakingRate?: null,
      newStakingRate?: null
    ): LogStakingStakingRateSetEventFilter;

    "LogStakingUnstaked(uint96,address,uint96,uint256,uint256)"(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingUnstakedEventFilter;
    LogStakingUnstaked(
      target?: null,
      user?: null,
      id?: null,
      amount?: null,
      newBalance?: null
    ): LogStakingUnstakedEventFilter;
  };

  estimateGas: {
    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getBundleInfo(
      bundle: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDip(overrides?: CallOverrides): Promise<BigNumber>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingWallet(overrides?: CallOverrides): Promise<BigNumber>;

    implementsIStaking(overrides?: CallOverrides): Promise<BigNumber>;

    isStakeOwner(
      id: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rateDecimals(overrides?: CallOverrides): Promise<BigNumber>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;

    rewardReserves(overrides?: CallOverrides): Promise<BigNumber>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unstake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unstakeAndClaimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    calculateCapitalSupport(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRequiredStaking(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      tokenAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRewards(
      amount: PromiseOrValue<BigNumberish>,
      duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateRewardsIncrement(
      stakeInfo: IStaking.StakeInfoStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    capitalSupport(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createStake(
      target: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getBundleInfo(
      bundle: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDip(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getInfo(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakingWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    implementsIStaking(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakeOwner(
      id: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isStakingSupportedForType(
      targetType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isUnstakingSupported(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    rateDecimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    refillRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rewardReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setRewardRate(
      rewardRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setStakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      stakingRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakes(
      target: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    stakingRate(
      chain: PromiseOrValue<BytesLike>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toChain(
      chainId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    toRate(
      value: PromiseOrValue<BigNumberish>,
      exp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unstake(
      id: PromiseOrValue<BigNumberish>,
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unstakeAndClaimRewards(
      id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawRewardReserves(
      dipAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
